# 13 웹 애플리케이션과 영속성 관리

- 컨테이너 환경에서 동작하는 JPA의 내부 동작 방식을 이해하지 못하면 문제가 발생했을 때 해결하기가 쉽지 않다. 해결방안 알아보자

# 13.1 트랜잭션 범위의 영속성 컨텍스트
- J2SE 순수환경에서는 JPA 사용시 개발자가 직접 엔티티 매니저를 생성하고 트랜잭션도 관리해야 한다
- Spring, J2EE 컨테이너 환경에서는 JPA 사용시 컨테이너가 제공하는 전략을 따라야 한다

## 13.1.1 스프링 컨테이너의 기본 전략
- 스프링 컨테이너는 **트랜잭션 범위의 영속성 컨텍스트 전략**을 기본으로 사용한다
  - 트랜잭션의 범위 == 영속성 컨텍스트의 생존 범위
  - 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다 (멀티스레드 상황에서도 서로 트랜잭션 다르므로 영속성 컨텍스트가 다르다)
- 보통 서비스 계층에서 `@Transaction` 을 통해 스프링 트랜잭션 AOP 동작시킴
  - 메소드 호출 직전에 트랜잭션 시작, 메소드 정상 종료시 트랜잭션 커밋하면서 종료
  - 트랜잭션 커밋 시 JPA 는 영속성 컨텍스트 플러시를 통해 디비에 반영
  - 예외 발생시 트랜잭션 롤백, 플러시를 호출하지 않음
  - 메소드 정상 종료시 가져온 엔티티들은 준영속 상태가 된다
- 복잡한 멀티스레드 상황, 트랜잭션을 컨테이너가 처리해준다 (개발자는 싱글 스레드 앱 개발 하듯이 하면됨)

# 13.2 준영속 상태와 지연 로딩
- 서비스, 레포지토리에선 조회한 엔티티가 영속 상태 이지만 컨트롤러, 뷰 같은 표현 계층에선 준영속상태가 된다
- 변경 감지 기능은 영속성 컨텍스트가 살아있는 서비스 계층 까지만 동작하고, 표현계층에서는 동작하지 않는다
  - 오히려 데이터를 보여줘야하기만 하는 표현 계층에서 변경이 일어나면 계층간의 책임이 모호해지고, 유지보수에 어려움을 가진다
- 준영속상태의 가장 큰 문제는 지연 로딩 기능이 동작하지 않는 문제 해결방법
  1. 뷰가 필요한 엔티티를 미리 로딩해두는 방법
  2. OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법
- 뷰가 필요한 엔티티를 미리 로딩해두는 방법
  1. 글로벌 페치 전략 수정
  2. JPQL 페치 조인
  3. 강제로 초기화

## 13.2.1 글로벌 페치 전략 수정
- 페치 타입을 지연로딩에서 즉시로딩으로 수정
- 단점
  - 사용하지 않는 엔티티를 로딩한다
    - 참조는 하고있지만 쓰지 않는 엔티티도 로딩해온다   
  - N+1 문제가 발생한다 
    - 가장 조심해야 하는것
    - 일대일로 가져올때는 괜찮다
    - Orders 를 가져올때 문제 발생
    - `orders = em.creageQuery("select o from Order o", Order.class).getResultList();`
    - JPA는 페치 전략을 참고하지 않고 JPQL만 분석해서 SQL을 생성한다
    - 동작 순서
      1. `select o from Order o` 분석해서 `select * from Order` 생성
      2. 데이터베이스에서 결과를 받아 order 엔티티 인스턴스들을 생성
      3. Order.member의 글로벌 페치 전략이 즉시 로딩이므로 order를 로딩하는 즉시 연관된 member도 로딩
      4. 연관된 member를 영속성 컨텍스트에서 찾는다
      5. 만약 없다면 `SELECT * FROM MEMBER WHERE id=?` SQL을 조회한 order엔티티 수만큼 실행한다
    - 만약 조회한 order 엔티티가 10개이면 SQL도 10번 실행
    - N+1 문제는 JPQL 페치 조인으로 해결할 수 있다
## 13.2.2 JPQL 페치 조인
- 글로벌 페치 전략을 즉시 로딩으로 설정시 앱 전체에 영향을 주므로 비효율적
- 페치 조인은 JPQL 호출 시점에 함께 로딩할 엔티티를 선택 가능
- JPQL join 뒤에 fetch 붙이면 됨
- 페치 조인 사용시 SQL JOIN 사용해서 페치 조인 대상까지 함께 조회하므로 N+1 문제가 발생하지 않는다
### JPQL 페치 조인의 단점
- 현실적인 대안이긴 하지만 무분별하게 사용하면 화면에 맞춘 레포지토리 메소드가 증가할 수 있다
- 각각의 뷰를 위해 페치조인을 쓰는 메소드. 안쓰는 메소드 만들수도 있다
- 이는 표현 계층이 데이터 접근 계층을 침범하는 행위
- 대안으로는 페치조인을 쓰는 메소드 하나만 만들자, join 은 성능에 미치는 영향이 미비하다

## 13.2.3 강제로 초기화
- 영속성 컨텍스트가 살아있을 때 표현 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법
- 프록시 객체를 게터 메소드를 통해 강제로 초기화시킴
- 하이버네이트라면 `initialize()` 메소드로 초기화시킴
- 이것도 표현계층의 침범으로 보일수 있다
- 그래서 서비스 계층에서 `FACADE`라는 계층 만들어 초기화 역할 준다

## 13.2.4 FACADE 계층 추가

