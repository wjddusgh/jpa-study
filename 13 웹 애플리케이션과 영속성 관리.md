# 13 웹 애플리케이션과 영속성 관리

- 컨테이너 환경에서 동작하는 JPA의 내부 동작 방식을 이해하지 못하면 문제가 발생했을 때 해결하기가 쉽지 않다. 해결방안 알아보자

# 13.1 트랜잭션 범위의 영속성 컨텍스트
- J2SE 순수환경에서는 JPA 사용시 개발자가 직접 엔티티 매니저를 생성하고 트랜잭션도 관리해야 한다
- Spring, J2EE 컨테이너 환경에서는 JPA 사용시 컨테이너가 제공하는 전략을 따라야 한다

## 13.1.1 스프링 컨테이너의 기본 전략
- 스프링 컨테이너는 **트랜잭션 범위의 영속성 컨텍스트 전략**을 기본으로 사용한다
  - 트랜잭션의 범위 == 영속성 컨텍스트의 생존 범위
  - 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다 (멀티스레드 상황에서도 서로 트랜잭션 다르므로 영속성 컨텍스트가 다르다)
- 보통 서비스 계층에서 `@Transaction` 을 통해 스프링 트랜잭션 AOP 동작시킴
  - 메소드 호출 직전에 트랜잭션 시작, 메소드 정상 종료시 트랜잭션 커밋하면서 종료
  - 트랜잭션 커밋 시 JPA 는 영속성 컨텍스트 플러시를 통해 디비에 반영
  - 예외 발생시 트랜잭션 롤백, 플러시를 호출하지 않음
  - 메소드 정상 종료시 가져온 엔티티들은 준영속 상태가 된다
- 복잡한 멀티스레드 상황, 트랜잭션을 컨테이너가 처리해준다 (개발자는 싱글 스레드 앱 개발 하듯이 하면됨)

# 13.2 준영속 상태와 지연 로딩
- 서비스, 레포지토리에선 조회한 엔티티가 영속 상태 이지만 컨트롤러, 뷰 같은 표현 계층에선 준영속상태가 된다
