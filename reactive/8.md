# 08 클라우드 스트림으로 확장하기

# 메시지 브로커, 메시지 기반 시스템의 핵심
- 리액티브 시스템의 본질 : 메시지 중심의 통신
- 모놀리틱 -> MSA 로 위치 투명성을 보장하는 탄력적인 시스템 만드는 것
- 서비스 관리, 모니터링 및 서비스 스케일링과 같은 새로운 범주의 문제점 가짐

## 서버사이드 로드 밸런싱
- 분산 시스템 개발 초기엔 위치 투명성, 탄력성을 얻는 방법중 하나로 HAProxy/Nginx 같은 외부 로드밸런서 사용(진입점 혹은 전체 시스템 대한 중앙 로드 밸런서로)
- 로드 밸런서
  - 하위 인스턴스의 레지스트리 역할 수행
  - 전체 그룹 로드 및 메트릭을 기반으로 스케일링 프로세스 시작 가능
  - 문제점
    - 로드가 높을 때 로드 밸런서가 시스템의 핫스팟 될 수 있음
    - 로드밸런서 비용이 높다
    - 백업 시스템에도 로드 밸런서가 필요할 수도 있다
    - 로드밸런서 관리, 모니터링을 위한 인프라 비용 추가  

## 스프링 클라우드와 Ribbon을 이용한 클라이언트 사이드 로드 밸런싱
- 각 서비스가 다른 서비스의 가용한 인스턴스를 확인하기 위하여 특정한 클라이언트와 통신을 시도
- 로드 밸런서는 각 서비스의 일부
- 전용 외부 로드밸런서에 대한 의존성 제거해줌 -> SPoF 없어져 확장성 향상
- 서비스 가용성 정보는 시스템의 나머지 서비스에서 어떻게든 접근할 수 있어야함
- Ribbon
  - 넷플릭스가 만든 클라이언트측 로드밸런서
  - 서비스 인스턴스 목록 사용해 로드 관리하는 방법
    - 각 로드밸런서는 동기화 안되므로 한 인스턴스에 과부하 줄수도 있음
    - 리액티브 요구사항과 거리가 멈
  - 유레카 같은 서비스 레지스트리와 통합한 방법
    - 서비스 복제본에 대한 가용성을 지속적으로 업데이트
    - 작은 서비스 클러스터에서 잘 작동
    - 시스템 상태 정보 업데이트, 유지에 많은 노력 필요(spof)
    - 클러스터가 동적일수록 서비스 레지스트리 정보가 안맞을 수 있음

## 탄력적이고 신뢰성 있는 메시지 전달 계층 역할의 메시지 브로커
- 메시지큐를 명시적으로 사용해 로드밸런싱
- 서버사이드 로드밸런싱과 비슷하지만, 비동기적으로 동작함
- 메시지큐는 독립적인 서비스로 작동
  - 메시지를 통해 시스템에 있는 워커의 수 알 수 있고, 이를 기반으로 부하 관리 가능
  - 각 워커는 내부적으로 배압 관리, 메시지 수신 가능
  - spof 같지만 아님, 메시지 큐에 넣고 빼고가 독립적이고, 메시지큐 복제로 확장성도 향상
  - 특정 그룹에 메시지 몰리는 부하 막기 위해 메시지 브로커 사용 가능
  - 메시지 브로커는 리밸런싱 메커니즘을 통해 부하 관리 가능
  - 메시지 브로커가 리액티브 시스템이면 아주 좋아짐 
  - 메시지 브로커가 손상된 경우에도 메시지 유실은 안일어남

## 메시지 브로커의 현황
- 다양한 오픈소스 솔루션 존재, 카프카가 주로 쓰이는듯
   
## 스프링 생태계와 연결해주는 스프링 클라우드 스트림
- 스프링 클라우드 스트림
  - 비동기식 다중 서비스 메시징을 위한 프로그래밍 모델 제공
  - 스프링 Integration, 스프링 메시지 모듈 기반으로 구축됨
  - 인터페이스를 통한 통신 대체하기 위해 서비스간의 통신을 지원하는 두가지 애노테이션 제공
    - @Output : 메시지를 전달할 큐 이름 정의
    - @Input : 메시지를 수신하는 큐 정의
    - @EnableBinding : 스프링 클라우드 스트림을 스트링밍 인프라와 통합해줌
    - @StreamEmitter : 발생하는 스트림이 리액티브 소스라는 것을 확실하게 해줌
    - @StreamListner : 메시지 브로커로부터 메시지 수신한다는것을 명시
 
## 클라우드 환경에서의 리액티브 프로그래밍
- 마이크로서비스간의 플로우 상호 작용 이해는 매우 중요하지만, 도구의 도움이 필요함
- AWS 람다가 좋다고 함

### 스프링 클라우드 데이터 플로
- 데이터 통합 및 실시간 데이터 처리 파이프라인을 구축하기 위한 도구
- 기능적 비즈니스 로직 개발과 개발된 컴포넌트 간의 실제 연계 및 통합을 분리하는것(기능적 요소와 정적인 구성요소 분리)
- 스트림 프로세싱 개념을 사용하기에 모든 통신은 분산 메시지 브로커를 통해 수행됨
  - 프로세스 실패가 발생해도 추가적인 노력없이 다른 실행 프로그램에 다시 전달됨
- HTTP 엔드포인트 사용 가능

## 스프링 클라우드 펑션을 활용한 잘게 쪼개진 애플리케이션
- 펑션 : 함수를 통해 비즈니스 로직을 발전시키는 것
  - 개별 비즈니스 로직과 런타임의 특성을 분리할 수 있는 기능 제공 -> 동일한 함수를 다른 방식, 다른 위치에서 재사용 가능
  - 다른 플랫폼에서 사용할 수 잇는 함수 배포용 어댑터 존재
  - 자바 함수 직접 업로드와 달리 대부분 스프링 기능을 사용할 수 있으며 특정 클라우드 공급자 SDK에 의존적이지 않게 작성 가능
  - 사전 정의된 함수 뿐 아니라 스프링 설정파일에서도 문자열로 함수를 선언할 수 있는 런타임 컴파일러가 내장돼 있음
  - 그래서 FaaS 구현 가능
  - spring-cloud-function-task 통해 동일한 설정파일 사용해 파이프에서 해당 함수 실행할 수 있도록 해줌  
  - jar 실행시 매개변수로 넣어줄수도있음(ex. java -jar tmp.jar --spring.cloud.function.imports.a.type=...)
  - 스프링 클라우드 펑션 디플로이어 사용시 독립적인 함수로만 실행도 가능함
  - 스프링 부트 씬 런처 : jar 가볍게 줄여주고 실행시간 감소시켜줌
  - 위 두개 섞으면 fat-jar 배포 문제 해결 가능하다고함

## 스프링 클라우드 - 데이터 플로의 일부로서의 함수
- 스프링 클라우드 스타터 스트림 앱 펑션
  - 순수 jar 파일 사용 가능
  - 스프링부트에서 추가적인 부담 없이 스프링 클라우드 데이터 플로와 함께 jar 파일 배포 가능
- 라우터 싱크 : 수신 메시지를 다른 메시지 큐로 라우팅 해줌(결과에 따른 목적지 변경 용도)
- 수신메시지를 db에 저장하려면 싱크 사용(ex. MongoDB Sink)
  - 메시지를 저장하면서 동시에 다음 단계로 메시지 전달도 가능
- 설정 내용과 프로퍼티를 전달해 원클릭(또는 명령)으로 배포할수 있는 기능 제공
- 시스템 안정성, 확장성 및 처리량 향상 가능
- 메시지 브로커 사용 같은 추가적인 통신 부하로 인해 요청에 대한 전체 처리시간이 느려질 수도 있다
- 이러한 지연 허용가능할 때만 사용하면 좋다

# 리액티브 메시지 전달을 위한 낮은 지연 시간의 RSocket
- 지연 허용안되는경우엔 여태의 방법 곤란
- 짧은 통신 솔루션 : 서비스 사이에 지속적이고 직접적으로 통신을 연결하는것
- 이건 TCP, 웹소켓이 딱이지만, 리액티브에는 안맞음
- 대체 솔루션이 RSocket

## RSocket vs. 리액터-네티
- 추상 어댑터
- 리액터-네티
  - 메시지 받을 준비가 됐을 때만 수신 메시지를 받아서 처리할 수 있다
  - request() 를 통해 네트워크 준비상태 알 수 있다
  - 컴포넌트가 실제 요청하는 숫자가 네트워크의 한계를 넘지 않는다
  - 빠른 pub, 느린 sub에서는 계속 소켓 버퍼에 이벤트 일부가 버퍼링되고, 너무 쌓여 유실 가능성 up
  - 바이트 단위로 tcp 흐름제어하면 애플리케이션 자체 성능이 느려짐
  - 스트림을 여러개로 논리적으로 다중화하고 싶어도 동일한 커넥션 재사용 불가
- RSocket
  - 리액티브 스트림 원래 의미에 부합하는 바이너리 프로토콜 제공
  - 가능한 개수만큼 한번에 보냄
  - 서비스간 상호작용(통신)이 적어 커넥션 사용이 비효율적으로 보이지만, 서버-클라 간에 여러 스트림에 대해 동일한 소켓 커넥션 재사용 가능해서 최적화
  - 요청/응답, 요청/스트림, fire-and-forget, 채널 등 다양한 비동기 메시지 전달 모델 지원, 모두 처음엔 단 하나의 커넥션만 사용

## 자바에서 RSocket 사용
- 리액터 3 기반
- RSocket 인터페이스는 클라-서버 양쪽 핸들러 다 표현 가능
- p2p 이므로 양측 모두 요청 처리 가능
- 유레카 같은 서비스 레지스트리와 통합 가능(RSocket LoadBalancer) -> 확장성 good
- 리액티브 스트림 의미 체계를 따르는 통신 프로토콜
- 네트워크 경계를 넘어서는 배압 제어 지원

## RSocket vs. gRPC
- gRPC
  - 리액티브 스트림과 거의 유일한 메시징 의미 체계(Protobuf)를 가짐
  - RxJava 1의 Observer와 동일한 인터페이스 구조
  - api가 Stream 인터페이스 제공
  - 네트워크 경계를 넘어서는 배압 제어 는 안되지만, http/2 기반으로 세분화된 흐름 제어 지원
  - RSocket는 프로토콜인데 이건 RPC 프레임워크임
  - 기본적으로 Protobuf 사용하지만 JSON 지원도 가능(RSocket은 리액티브 구현만 제공)
  - RSocket-RPC 라는 RPC프레임워크 존재
    - RSocket 프로토콜 위에 구축되어서 모든 gRPC 기능 제공

## 스프링 프레임워크에서 RSocket 사용
- 애노테이션 기반으로 스프링 생태계와 통합 시도
- 그중 하나가 스프링 클라우드 소켓
  - @EnableReactiveSockets
- 공식 스프링 클라우드가 아닌 외부에서 개발 진행중이라고 함
- 심지어 최초 개발자가 더이상 지원 안한다?

## 다른 프레임워크에서의 RSocket
### ScaleCube 프로젝트
- 얘도 스프링과 통합을 제공하는 애노테이션 기반 api 제공
### Proteus 프로젝트
- 클라우드 네이티브 마이크로서비스 플랫폼
- RSocket-RPC 사용, 메시지 라우팅, 모니터링 및 추적을 위한 모듈 제공
- 얘도 스프링과 통합, 애노테이션 기반 제공

## RSocket 요약
- 양방향 연결을 리액티브하게 해줌
- 하드웨어 영향 줄이기 위해 설계됨
- 모든 언어로 구현할 수 있는 프로토콜임
  
