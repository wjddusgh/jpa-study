# 08 클라우드 스트림으로 확장하기

# 메시지 브로커, 메시지 기반 시스템의 핵심
- 리액티브 시스템의 본질 : 메시지 중심의 통신
- 모놀리틱 -> MSA 로 위치 투명성을 보장하는 탄력적인 시스템 만드는 것
- 서비스 관리, 모니터링 및 서비스 스케일링과 같은 새로운 범주의 문제점 가짐

## 서버사이드 로드 밸런싱
- 분산 시스템 개발 초기엔 위치 투명성, 탄력성을 얻는 방법중 하나로 HAProxy/Nginx 같은 외부 로드밸런서 사용(진입점 혹은 전체 시스템 대한 중앙 로드 밸런서로)
- 로드 밸런서
  - 하위 인스턴스의 레지스트리 역할 수행
  - 전체 그룹 로드 및 메트릭을 기반으로 스케일링 프로세스 시작 가능
  - 문제점
    - 로드가 높을 때 로드 밸런서가 시스템의 핫스팟 될 수 있음
    - 로드밸런서 비용이 높다
    - 백업 시스템에도 로드 밸런서가 필요할 수도 있다
    - 로드밸런서 관리, 모니터링을 위한 인프라 비용 추가  

## 스프링 클라우드와 Ribbon을 이용한 클라이언트 사이드 로드 밸런싱
- 각 서비스가 다른 서비스의 가용한 인스턴스를 확인하기 위하여 특정한 클라이언트와 통신을 시도
- 로드 밸런서는 각 서비스의 일부
- 전용 외부 로드밸런서에 대한 의존성 제거해줌 -> SPoF 없어져 확장성 향상
- 서비스 가용성 정보는 시스템의 나머지 서비스에서 어떻게든 접근할 수 있어야함
- Ribbon
  - 넷플릭스가 만든 클라이언트측 로드밸런서
  - 서비스 인스턴스 목록 사용해 로드 관리하는 방법
    - 각 로드밸런서는 동기화 안되므로 한 인스턴스에 과부하 줄수도 있음
    - 리액티브 요구사항과 거리가 멈
  - 유레카 같은 서비스 레지스트리와 통합한 방법
    - 서비스 복제본에 대한 가용성을 지속적으로 업데이트
    - 작은 서비스 클러스터에서 잘 작동
    - 시스템 상태 정보 업데이트, 유지에 많은 노력 필요(spof)
    - 클러스터가 동적일수록 서비스 레지스트리 정보가 안맞을 수 있음

## 탄력적이고 신뢰성 있는 메시지 전달 계층 역할의 메시지 브로커
- 메시지큐를 명시적으로 사용해 로드밸런싱
- 서버사이드 로드밸런싱과 비슷하지만, 비동기적으로 동작함
- 메시지큐는 독립적인 서비스로 작동
  - 메시지를 통해 시스템에 있는 워커의 수 알 수 있고, 이를 기반으로 부하 관리 가능
  - 각 워커는 내부적으로 배압 관리, 메시지 수신 가능
  - spof 같지만 아님, 메시지 큐에 넣고 빼고가 독립적이고, 메시지큐 복제로 확장성도 향상
  - 특정 그룹에 메시지 몰리는 부하 막기 위해 메시지 브로커 사용 가능
  - 메시지 브로커는 리밸런싱 메커니즘을 통해 부하 관리 가능
  - 메시지 브로커가 리액티브 시스템이면 아주 좋아짐 
  - 메시지 브로커가 손상된 경우에도 메시지 유실은 안일어남

## 메시지 브로커의 현황
- 다양한 오픈소스 솔루션 존재, 카프카가 주로 쓰이는듯
   
## 스프링 생태계와 연결해주는 스프링 클라우드 스트림
- 스프링 클라우드 스트림
  - 비동기식 다중 서비스 메시징을 위한 프로그래밍 모델 제공
  - 스프링 Integration, 스프링 메시지 모듈 기반으로 구축됨
  - 인터페이스를 통한 통신 대체하기 위해 서비스간의 통신을 지원하는 두가지 애노테이션 제공
    - @Output : 메시지를 전달할 큐 이름 정의
    - @Input : 메시지를 수신하는 큐 정의
    - @EnableBinding : 스프링 클라우드 스트림을 스트링밍 인프라와 통합해줌
    - @StreamEmitter : 발생하는 스트림이 리액티브 소스라는 것을 확실하게 해줌
    - @StreamListner : 메시지 브로커로부터 메시지 수신한다는것을 명시
 
## 클라우드 환경에서의 리액티브 프로그래밍
- 마이크로서비스간의 플로우 상호 작용 이해는 매우 중요하지만, 도구의 도움이 필요함
- AWS 람다가 좋다고 함

### 스프링 클라우드 데이터 플로
- 데이터 통합 및 실시간 데이터 처리 파이프라인을 구축하기 위한 도구
- 기능적 비즈니스 로직 개발과 개발된 컴포넌트 간의 실제 연계 및 통합을 분리하는것(기능적 요소와 정적인 구성요소 분리)
- 스트림 프로세싱 개념을 사용하기에 모든 통신은 분산 메시지 브로커를 통해 수행됨
  - 프로세스 실패가 발생해도 추가적인 노력없이 다른 실행 프로그램에 다시 전달됨
- HTTP 엔드포인트 사용 가능

## 스프링 클라우드 펑션을 활용한 잘게 쪼개진 애플리케이션
- 펑션 : 함수를 통해 비즈니스 로직을 발전시키는 것
  - 개별 비즈니스 로직과 런타임의 특성을 분리할 수 있는 기능 제공 -> 동일한 함수를 다른 방식, 다른 위치에서 재사용 가능
  - 다른 플랫폼에서 사용할 수 잇는 함수 배포용 어댑터 존재
  - 자바 함수 직접 업로드와 달리 대부분 스프링 기능을 사용할 수 있으며 특정 클라우드 공급자 SDK에 의존적이지 않게 작성 가능
  - 사전 정의된 함수 뿐 아니라 스프링 설정파일에서도 문자열로 함수를 선언할 수 있는 런타임 컴파일러가 내장돼 있음
  - 그래서 FaaS 구현 가능
  - spring-cloud-function-task 통해 동일한 설정파일 사용해 파이프에서 해당 함수 실행할 수 있도록 해줌  
  - jar 실행시 매개변수로 넣어줄수도있음(ex. java -jar tmp.jar --spring.cloud.function.imports.a.type=...)
  - 스프링 클라우드 펑션 디플로이어 사용시 독립적인 함수로만 실행도 가능함
  - 스프링 부트 씬 런처 : jar 가볍게 줄여주고 실행시간 감소시켜줌
  - 위 두개 섞으면 fat-jar 배포 문제 해결 가능하다고함

## 스프링 클라우드 - 데이터 플로의 일부로서의 함수
- 스프링 클라우드 스타터 스트림 앱 펑션
  - 순수 jar 파일 사용 가능
  - 스프링부트에서 추가적인 부담 없이 스프링 클라우드 데이터 플로와 함께 jar 파일 배포 가능
- 라우터 싱크 : 수신 메시지를 다른 메시지 큐로 라우팅 해줌(결과에 따른 목적지 변경 용도)
- 수신메시지를 db에 저장하려면 싱크 사용(ex. MongoDB Sink)
  - 메시지를 저장하면서 동시에 다음 단계로 메시지 전달도 가능
- 설정 내용과 프로퍼티를 전달해 원클릭(또는 명령)으로 배포할수 있는 기능 제공
- 시스템 안정성, 확장성 및 처리량 향상 가능
- 메시지 브로커 사용 같은 추가적인 통신 부하로 인해 요청에 대한 전체 처리시간이 느려질 수도 있다
- 이러한 지연 허용가능할 때만 사용하면 좋다

# 리액티브 메시지 전달을 위한 낮은 지연 시간의 RSocket
- 지연 허용안되는경우엔 여태의 방법 곤란
- 짧은 통신 솔루션 : 서비스 사이에 지속적이고 직접적으로 통신을 연결하는것
