# 6 웹플럭스 - 비동기 논블로킹 통신

# 리액티브 기반 서버 기술의 핵심: 웹플럭스

- 스프링 프레임워크 인프라는 전체적으로 서블릿API 를 기반으로 둘으 강하게 결합돼 있음
  - ex. 스프링 웹 MVC는 전체적으로 프런트 컨트롤러 패턴 기반
- 스프링 웹 모듈에서 더 나은 추상화 수준을 제공
  - 애노테이션 기반의 컨틀로러와 같은 많은 기능을 모아둔 레고블록 같음
  - 공통 인터페이스를 부분적으로 구현 및 분리하고 있지만, 블로킹 으로 설계됨
- 수년간 편리한 프로그래밍 모델이었음
- 서블릿 API 는 3.1 부터 비동기 논블로킹 통신 지원, 근데 스프링 MVC는 서블릿과 많은 차이가 있어 요청 <> 응답 사이에 논블로킹 동작을 허용하지 않음
- 새로운 구축이 필요하겠음

## 리액티브 웹의 핵심
- 스프링 MVC 내부 API에 추가돼야할 것은 서블릿 API에 대한 직접적읜 의존성 -> 그래서 최종 리액티브 솔루션은 서블릿 API와 유사한 인터페이스를 가져야함
- `ServerHttpRequest`, `ServerHttpResponse`, 이들을 반환해주는 인터페이스 `ServerWebExchange`등을 구현 가능
  - 기존 모델과 비슷함, 하지만 리액티브 스트림의 비도이 논블로킹 특성으로 스트리밍 기반의 기능을 사용할 수 있고, 콜백기반 API와 콜백 지옥으로부터 보호해줌 
  - `Webhandler`, `WebFilterChan` 등의 설계로 인해 스프링 웹플럭스 사용자는 특정 서버 엔진이 어떻게 작동하는지 알 필요 없음 -> 적절한 수준의 추상화 덕분

## 리액티브 웹 MVC 프레임워크
- 스프링 웹 MVC 모듈 핵심은 애토네이션 기반 프로그래밍 모델 -> 리액티브 방식으로 해도 애노테이션 기반 모델은 지원해야함
- 새로운 인프라를 구축하는 대신 기존 MVC 인프라를 재사용하고 동기 통신을 Flux, Mono, Publisher 같은 리액티브 타입으로 교체할 수도 있음
- 예시 중에 `ServerWebExchange` 는 req + res 동시에 있기에 기존보다 간결해짐
- 옛날 View는 하던 일도 많다. 뷰 검색을 HandlerAdapter가 수행하도록 역할이 명확해져서 개선점이라 말할 수 있다고 함
- 다시 설계된 리액티브 웹 MVC 스택
  - 맨 처음 요청 처리하는 서버 엔진이 서블릿 API 기반 서버에만 국한되지 않음(네티, 언더토 등 포함)
  - 각 서버 엔진에는 자체적으로 요청을 처리할 수 있는 어댑터 존재해서 내부 표현을 ServerHttpRequest, ServerHttpResponse에 매핑함
  - HttpHandler 계층 : req, res, 사용자 세션 및 관련 정보를 ServerWebExchange 인스턴스로 결합
  - WebFilterChain 계층 : 정의된 WebFilter를 체인으로 구성, 연결된 인스턴스의 WebFilter.filter() 실행해 필터링
  - HandlerMapping의 인스턴스를 찾고 적합한 인스턴스 호출, 단순한 기능 요청 처리를 넘어서는 RouterFunctionMapping임
  - RequestMappingHandlerAdapter 계층 : 이전과 같은 기능을 하지만, 리액티브 스트림 사용

## 웹플럭스로 구현하는 순수한 함수형 웹
- `RouterFunctions` : RouterFunction 인터페이스를 다른 동작으로 반환하는 다양한 팩토리 메서드 제공
- `RequestPredicates` : 입력받은 요청을 다른 관점에서 확인할 수 있음, RequestMapping과 유사한듯
- 함수형 웹 프레임워크를 사용하면 전체 스프링 인프라를 시작하지 않고도 웹 응용 프로그램을 빌드할 수 있다
  - 예시를 보니 람다 내부에 사용되는 친구는 시작할 때 안시작하나봄 

### WebClient: 논블로킹을 지원하는 통신 클라이언트
- `RestTemplate`의 대체품
```java
WebClient.create("http://localhost/api")  // WebClient 인스턴스 생성
  .get()
  .uri("/users/{id}", userId)             // 상대 경로 지정
  .retrieve()
  .bodyToMono(User.class)
  .map(...)
  .subscribe();                           // 원격 호출 실행
```
- 본문 처리 이외에도 응답, 쿠키, 헤더 처리 등 도 가능
- `DefaultWebClient` 는 쉽게 변경 가능

## 리액티브 웹소켓 API
- 클라이언트, 서버 모두 지원하는 웹소켓이 있음
### 서버 측 웹소켓 API
- `WebSocketHandler` 제공
- 리액티브 타입 기반으로 만들어져 있음
### 클라이언트 측 웹소켓 API
- `WebSocketClient`
- 서버의 메시지를 처리하는 용도와 메시지를 다시 보내기 위한 용도로 `WebSockethandler` 인터페이스 사용
### 웹플럭스 웹소켓과 스프링 웹소켓
- 서블릿 기반 웹소켓 모듈과 많이 유사함
- 웹플럭스는 완전한 논블로킹 쓰기 및 읽기 제공
- 엔드포인트 설정은 어렵나봄

### 웹소켓 경량화를 위한 리액티브 SSE
- SSE 스트림을 애노테이션 기반 프로그래밍으로 하면 객체 무한 스트림이 반환됨
- 웹플럭스는 이미 웹소켓이 포함이라 스트리밍 모델 구성시 추가적인 상용구 코드 필요하지 않음
- 바이너리 인코딩 지원안함, UTF-8 인코딩 지원 -> 메시지 크기가 작고 트래픽이 적어 대기시간 짧을때 유용함
- 결론 : SSE 는 웹소켓의 좋은 대안
  - 근데 웹소켓은 양방향, SSE는 단방향
## 리액티브 템플릿 엔진
- 스프링 5.x 와 웹플럭스 모듈 사용하면 대부분의 템플릿 엔진(jsp, thymeleaf(얜 또 향후 지원한다고 함) 등) 사용 불가, 프리마커 렌더링 엔진은 지원함
- 뷰 렌더링 사용 가능
- 대충 프리마커는 논블로킹 렌더링 지원 안해서 모든 데이터를 모아야 시작해서 안좋나봄
- 책 시점에선 타임리프가 논블로킹 지원해서 무한 스트림을 빠르게 시작은 되는데 템플릿당 한 데이터만 된다고 함

## 리액티브 웹 보안
- 수년 동안 스프링 시큐리티가 웹 MVC와 결합돼 서블릿 api의 `Filter`만 사용함
- `WebFilter` 생겨서 리액터 프로젝트의 컨텍스트 기능에 크게 의존하는 스택 구현

### SecurityContext를 리액티브 방식으로 사용하기
- SecurityContext에 접근하기 위해 `ReactiveSecurityContextHolder` 클래스 사용
- 기존의 동기적 구현과 상당히 유사, 기존과 동일한 애노테이션 사용

### 리액티브 방식으로 스프링 시큐리티 사용하기

## 다른 리액티브 라이브러리와의 상호 작용
- 핵심은 리액터프로젝트 3 이지만, 다른 라이브러리 사용 가능 -> RxJava 2 또는 Akka로 쉽게 대체 가능

# 웹플럭스 vs. 웹 MVC
## 프레임워크를 비교할 때는 법칙이 중요하다
- 예전에 비해 트래픽, 동적 콘텐츠 등으로 상황이 바뀜. 어떤 것을 주요하게 봐야할까
### 리틀의 법칙
- 지정한 대기 시간 만족하면서 정의된 양을 처리하기 위해 동시에 처리해야 하는 요청 수
- N = X * R
  - N : 시스템 상주하는 평균 요청 수
  - X : 처리량
  - R : 평균 응답 시간(대기 시간)

### 암달의 법칙
- 평균 응답시간에 순차적인 엑세스가 미치는 영향에 관한 것 -> 처리량에 관한 법칙
- 뭐 쫌 많이 복잡함
- 중요한건 전체적인 작업에 대한 병렬 처리 도입해도 병목현상에 의해 한계가 있다.
- 암달의 법칙을 리틀의 법칙과 결합해 비교해보면 병렬 작업 수를 늘리면 지연 시간이 선형으로 늘어난다 -> 병렬 수준을 높이더라도 추가 오버헤드가 발생한다

### USL(Universal Scalability Law)
- 순차적 실행 외에도 비일관성 이라는 또 하나의 치명적인 문제점이 있다고 함
- 비일관성 : 동시성을 지원하는 시스템이 공유 자원을 가진 경우에 일반적으로 나타나는 현상
  - 자바의 스레딩 모델이 좀 꾸지다는데,
    - 프로세서 숫자 < Thread 수 의 경우 cpu 액세스, 시간 확보를 위해 서로 다른 스레드간 직접적 충돌 발생을 해결해줘야함
- 보편적 확장성 법칙(USL) 은 암달의 법칙을 확장한 것
- USL 로 보게 되면 공유 엑세스 지점이 있다면 병렬 작업이 늘어나면 처리량이 늘긴 하는데 어느 변곡점에선 오히려 처리량이 줄어듬(작업수에 비례해 선형으로 대기시간이 증가해서)

## 철저한 분석과 비교
- 열심히 웹 MVC 와 웹플럭스를 다른 관점에서 비교해보자!
### 웹플럭스 및 웹 MVC의 처리 모델 이해
- 블로킹, 논블로킹 차이 -> 웹플럭스가 효율적으로 하나의 스레드를 사용 -> 멀티스레딩과의 차이뭐냐? -> usl에서 보이듯이 시스템 성능 저하 가능성 up
### 요청 처리 모델이 시스템 처리량 및 대기 시간에 미치는 영향
- 테스트 해봤는데(연결당 하나의 스레드를 할당하는 모델 vs 논블로킹 비동기 처리 모델), 두 모델 다 일정 병렬 작업수 이후 변곡점이 생겨 처리량이 감소
- but, 웹플럭스 모델이 2배 더 높은 처리량에서 수렴하게됨
- 웹 MVC는 스레드 풀이 너무 많은 메모리를 차지함 -> 메로리 한정적이면 최대 병렬 작업 수 한계도 있음
- 웹 MVC 모델 대안은 사용자별로 별도의 스레드 할당하는것(웹플럭스에서는 필요 없는 대안)

### 웹플럭스 처리 모델의 해결 과제
- 이벤트 루프가 아닌 한, 작업 자체가 오래걸리면(CPU 집약적인 작업, 작업 자체에 블로킹 포함인 것) 느림
- 웹플럭스는 적은 몇개의 스레드로 엄청난 양의 요청 비동기,논블로킹 처리 해야함 -> OS동작 잘 이해하고 써야함
- 자바는 근데 그러기에 좋지않나봄(JDK 내의 대다수 요청은 블로킹)
- 그래서 작업 자체가 엄청 복잡한 모델은 웹 MVC 스레딩 모델이 효율적

### 요청 처리 모델과 메모리 사용량과의 관계
- 웹 MVC 의 경우 병렬화가 늘어남에 따라 메모리 사용량이 늘어남 -> 메모리 사용에 비효율적
- 웹플럭스는 병렬 처리 늘어나도 메모리 사용 안정적

### 요청 처림 모델과 사용성 사이의 관계
- 정성적 지표 : 학습 시간
- 웹플럭스 어려워서 넷플릭스가 Zuul을 마이그레이션한 경험에서 아주 슬퍼했다고함

# 웹플럭스 애플리케이션
## 마이크로서비스 기반 시스템
- MSA는 I/O 통신이 많아 웹플럭스가 좋다
## 접속이 느린 클라이언트를 처리하는 시스템
- 모바일, 불안정한 네트워크는 접속이 느림, DoS 맞으면 훅감
- 웹플럭스는 느리더라도 그 동안 다른 이벤트 처리 상태를 제어 가능
## 스트리밍 또는 실시간 시스템
- 요구사항이 낮은 대기시간, 높은 처리량 인데 딱 맞음
