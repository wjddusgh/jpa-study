# 6 웹플럭스 - 비동기 논블로킹 통신

# 리액티브 기반 서버 기술의 핵심: 웹플럭스

- 스프링 프레임워크 인프라는 전체적으로 서블릿API 를 기반으로 둘으 강하게 결합돼 있음
  - ex. 스프링 웹 MVC는 전체적으로 프런트 컨트롤러 패턴 기반
- 스프링 웹 모듈에서 더 나은 추상화 수준을 제공
  - 애노테이션 기반의 컨틀로러와 같은 많은 기능을 모아둔 레고블록 같음
  - 공통 인터페이스를 부분적으로 구현 및 분리하고 있지만, 블로킹 으로 설계됨
- 수년간 편리한 프로그래밍 모델이었음
- 서블릿 API 는 3.1 부터 비동기 논블로킹 통신 지원, 근데 스프링 MVC는 서블릿과 많은 차이가 있어 요청 <> 응답 사이에 논블로킹 동작을 허용하지 않음
- 새로운 구축이 필요하겠음

## 리액티브 웹의 핵심
- 스프링 MVC 내부 API에 추가돼야할 것은 서블릿 API에 대한 직접적읜 의존성 -> 그래서 최종 리액티브 솔루션은 서블릿 API와 유사한 인터페이스를 가져야함
- `ServerHttpRequest`, `ServerHttpResponse`, 이들을 반환해주는 인터페이스 `ServerWebExchange`등을 구현 가능
  - 기존 모델과 비슷함, 하지만 리액티브 스트림의 비도이 논블로킹 특성으로 스트리밍 기반의 기능을 사용할 수 있고, 콜백기반 API와 콜백 지옥으로부터 보호해줌 
  - `Webhandler`, `WebFilterChan` 등의 설계로 인해 스프링 웹플럭스 사용자는 특정 서버 엔진이 어떻게 작동하는지 알 필요 없음 -> 적절한 수준의 추상화 덕분

## 리액티브 웹 MVC 프레임워크
- 스프링 웹 MVC 모듈 핵심은 애토네이션 기반 프로그래밍 모델 -> 리액티브 방식으로 해도 애노테이션 기반 모델은 지원해야함
- 새로운 인프라를 구축하는 대신 기존 MVC 인프라를 재사용하고 동기 통신을 Flux, Mono, Publisher 같은 리액티브 타입으로 교체할 수도 있음
- 예시 중에 `ServerWebExchange` 는 req + res 동시에 있기에 기존보다 간결해짐
- 옛날 View는 하던 일도 많다. 뷰 검색을 HandlerAdapter가 수행하도록 역할이 명확해져서 개선점이라 말할 수 있다고 함
- 다시 설계된 리액티브 웹 MVC 스택
  - 맨 처음 요청 처리하는 서버 엔진이 서블릿 API 기반 서버에만 국한되지 않음(네티, 언더토 등 포함)
  - 각 서버 엔진에는 자체적으로 요청을 처리할 수 있는 어댑터 존재해서 내부 표현을 ServerHttpRequest, ServerHttpResponse에 매핑함
  - HttpHandler 계층 : req, res, 사용자 세션 및 관련 정보를 ServerWebExchange 인스턴스로 결합
  - WebFilterChain 계층 : 정의된 WebFilter를 체인으로 구성, 연결된 인스턴스의 WebFilter.filter() 실행해 필터링
  - HandlerMapping의 인스턴스를 찾고 적합한 인스턴스 호출, 단순한 기능 요청 처리를 넘어서는 RouterFunctionMapping임
  - RequestMappingHandlerAdapter 계층 : 이전과 같은 기능을 하지만, 리액티브 스트림 사용

## 웹플럭스로 구현하는 순수한 함수형 웹
- `RouterFunctions` : RouterFunction 인터페이스를 다른 동작으로 반환하는 다양한 팩토리 메서드 제공
- `RequestPredicates` : 입력받은 요청을 다른 관점에서 확인할 수 있음, RequestMapping과 유사한듯
- 함수형 웹 프레임워크를 사용하면 전체 스프링 인프라를 시작하지 않고도 웹 응용 프로그램을 빌드할 수 있다
  - 예시를 보니 람다 내부에 사용되는 친구는 시작할 때 안시작하나봄 

### WebClient: 논블로킹을 지원하는 통신 클라이언트
- `RestTemplate`의 대체품
```java
WebClient.create("http://localhost/api")  // WebClient 인스턴스 생성
  .get()
  .uri("/users/{id}", userId)             // 상대 경로 지정
  .retrieve()
  .bodyToMono(User.class)
  .map(...)
  .subscribe();                           // 원격 호출 실행
```
- 본문 처리 이외에도 응답, 쿠키, 헤더 처리 등 도 가능
- `DefaultWebClient` 는 쉽게 변경 가능

## 리액티브 웹소켓 API
- 클라이언트, 서버 모두 지원하는 웹소켓이 있음
### 서버 측 웹소켓 API
- `WebSocketHandler` 제공
- 리액티브 타입 기반으로 만들어져 있음
### 클라이언트 측 웹소켓 API
- `WebSocketClient`
- 서버의 메시지를 처리하는 용도와 메시지를 다시 보내기 위한 용도로 `WebSockethandler` 인터페이스 사용
### 웹플럭스 웹소켓과 스프링 웹소켓
- 서블릿 기반 웹소켓 모듈과 많이 유사함
- 웹플럭스는 완전한 논블로킹 쓰기 및 읽기 제공
- 엔드포인트 설정은 어렵나봄

### 웹소켓 경량화를 위한 리액티브 SSE
- SSE 스트림을 애노테이션 기반 프로그래밍으로 하면 객체 무한 스트림이 반환됨
- 웹플럭스는 이미 웹소켓이 포함이라 스트리밍 모델 구성시 추가적인 상용구 코드 필요하지 않음
- 바이너리 인코딩 지원안함, UTF-8 인코딩 지원 -> 메시지 크기가 작고 트래픽이 적어 대기시간 짧을때 유용함
- 결론 : SSE 는 웹소켓의 좋은 대안
  - 근데 웹소켓은 양방향, SSE는 단방향
## 리액티브 템플릿 엔진
- 스프링 5.x 와 웹플럭스 모듈 사용하면 대부분의 템플릿 엔진(jsp, thymeleaf(얜 또 향후 지원한다고 함) 등) 사용 불가, 프리마커 렌더링 엔진은 지원함
- 뷰 렌더링 사용 가능
- 대충 프리마커는 논블로킹 렌더링 지원 안해서 모든 데이터를 모아야 시작해서 안좋나봄
- 책 시점에선 타임리프가 논블로킹 지원해서 무한 스트림을 빠르게 시작은 되는데 템플릿당 한 데이터만 된다고 함

## 리액티브 웹 보안


## 리액티브 템플릿 엔진
