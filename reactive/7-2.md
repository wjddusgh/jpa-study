### 페이징 지원
- 동기식 리포지토리에서 사용되는 방식이 리액티브 패러다임에 맞지 않아 스프링 데이터 팀이 의도적으로 페이징 지원 안하기로 했음
  - 이전에 반환된 레코드 수, 총 레코드 수 쿼리해야 하므로 안맞음
- Pageable 객체를 리포지토리에 전달하면 데이터 청크 가져올 수 있음
```java
public inter face ReactiveBookRepository
  extends ReactiveSortingRepository<Book, Long> {
  
  Flux<Book> findByAuthor(String author, Pageable pageable);
}

Flux<Book> result = reactiveBookRepository
  .findByAuthor('Andy Weir', PageRequest.of(1, 5));
```

### ReactiveMongoRepository 세부구현
- 스프링데이터 몽고디비 리액티브 모듈은 구현체가 `SimpleReactiveMongoRepository`
  - `ReactiveMongoRepository` 의 모든 메서드 구현 제공
  - `ReactiveMongoOperations` 인터페이스 사용해 저수준 모든동작 처리

```java
public Flux<T> findAllById(Publisher<ID> ids) {
  return Flux.from(ids) // 퍼블리셔에서 갖고와 Flux로 만듦
    .buffer() // 모든 id 수집
    .flatMap(this::findAllByID); // .findAllById(Iterable<ID> ids) 를 재정의해 하나의 요청으로 만듦
}
```
- 구현  
  - findAllById 메서드의 두가지 버전은 동일한 방식으로 동작하고 하나의 데이터베이스 쿼리만 만듦
  - saveAll() 의 경우 pub는 엔티티마다 쿼리, iter 는 같은 엔티티의 경우 하나의 쿼리로 사용
  - deleteAll() 의 경우 두가지 버전 모두 항상 엔티티마다 쿼리 생성
- ReactiveCrudRepository : 구현체가 런타임에 생성되어 실제 쿼리 보기 어려움(생성 방법은 동기식 CrudRepository와 비슷)
- RepositoryFactorySupport : ReactiveCrudRepository에 대한 적절한 프록시 생성
- ReactiveStringBasedMongoQuery : 메서드에 @Query 애노테이션 붙여서 쿼리 생성하는데 사용
- ReactivePartTreeMongoQuery : 메서드 이름 규칙 기반 쿼리 생성에 사용
- ReactiveMongoTemplate 로깅 레벨을 DEBUG 로 설정해서 모든 쿼리 추적 가능

### ReactiveMongoTemplate 사용하기

```java
public class RxMongoTemplateQueryService {
    private final ReactiveMongoOperations mongoOperations;
    // 생성자

    public Flux<Book> findBooksByTitle(String titleReg) {
        Query query = Query.query(new Criteria("title")
            .regex(titleReg)))
            .limit(100);
        return mongoOperations
          .find(query, Book.class, "book);
    }
}
```
- ReactiveMongoTemplate은 리액티브 몽고디비 커넥션 얻기 위해 ReactiveMongoDatabaseFactory 인터페이스 사용
- MongoConverter 사용해 엔티티<>도큐먼트 변환 가능

### Mongo DB 리액티브 드라이버 사용하기
- MongoDB 리액티브 스트림 자바 드라이버 기반(논블로킹 배압으로 비동기 스트림 처리 제공)
  - 몽고디비 비동기 자바 드라이버 도 있는데 이건 로우레벨이라 다루기 어려움(리액티브 드라이버가 이거 위에 구축됨)
  - 몽고디비 연결은 자바에서 동기식, 비동기식, 리액티브 드라이버 하나씩 있는거

```java
public class RxMongoDriverQueryService {
   private final MongoClient mongoClient;   // 인스턴스 참조

   public Flux<Book> findBooksByTitle(String regex) {  
      return Flux.defer(() -> {               // 실제 구독 발생까지 실행 연기
         Bson query = Filters.regex(titleRegex);    // Bson 타입으로 새 쿼리 정의

         return mongoClient
            .getDatabase(dbName)
            .getCollection("book")
            .find(query);         // 이전에 준비된 쿼리 실행
      })
         .map(doc -> new Book(      // 도큐먼트를 엔티티로 변환해 전달
            doc.getObjectId("id"),
            doc.getString("title"),
            doc.getInteger("pubYear"),
            // ... 나머지 매핑
         ));
   }
}
```
- 배압을 수동으로 처리안해도됨

### Cassandra 비동기 드라이버 사용하기
- 몽고랑 비슷한듯

## 리액티브 트랜잭션
- 리액터 컨텍스트에 보관한다

### MongoDB 4 의 리액티브 트랜잭션
- 버전 4 부터 다중 도큐먼트 트랜잭션 지원(도큐먼트 내의 도큐먼트)
  - 트랜잭션 내에서 메타 명령 실행, 컬랙션 또는 색인 생성 불가( 그래서 오류방지 위해 디비 설정 변경해야함)   
  - 이를 통해 계좌잔고 문제 해결 가능
```java
public interface WalletService {

   Flux<String> generateClients(Integer number, Integer defaultBalance);

   Mono<TxResult> transferMoney(
      Mono<String> fromOwner,
      Mono<String> toOwner,
      Mono<Integer> amount);

   Mono<Statistics> reportAllWallets();

   Mono<Void> removeAllClients();

   enum TxResult {
      SUCCESS,
      NOT_ENOUGH_FUNDS,
      TX_CONFLICT
   }
 }  
```
```java
 public Mono<OperationStats> runSimulation() {
         return Flux.range(0, iterations)   // 원하는 양만큼 반복 시뮬레이션
            .flatMap(i -> Mono
               .delay(Duration.ofMillis(rnd.nextInt(10))) // 트랜잭션 경합 유도를 위해 지연 시간 적용
               .publishOn(simulationScheduler)            // 트랜잭션 실행(scheduler 타입)
               .flatMap(_i -> {
                  String fromOwner = randomOwner();
                  String toOwner = randomOwnerExcept(fromOwner);
                  int amount = randomTransferAmount();

                  return walletService.transferMoney(     // 서비스 호출
                     Mono.just(fromOwner),
                     Mono.just(toOwner),
                     Mono.just(amount));
               }))
            .reduce(                    // transferMoney 호출 결과는 TxResult중 하나이므로 시뮬레이션 통계 추적
            OperationStats.start(), 
            OperationStats::countTxResult);  
      }
```
- 잘 구현됐다면 시스템 총 금액 변경x
- 이번엔 리액티브 트랜잭션 사용한 구현
```java
public class TransactionalWalletService implements WalletService {
   private final ReactiveMongoTemplate mongoTemplate; // 이 책 시점 기준 리액티브 몽고디비 커넥터는 템플릿 레벨에서만 트랜잭션 지원하고 리포지토리 레벨에서는 지원X
    
   @Override 
   public Mono<TxResult> transferMoney(   
      Mono<String> fromOwner,
      Mono<String> toOwner,
      Mono<Integer> requestAmount
   ) {
      return Mono.zip(fromOwner, toOwner, requestAmount)  // zip 이용해 모든 매개변수 구독
         .flatMap(function((from, to, amount) -> {        // TupleUtils.function() 사용해 각각의 항목으로 해석
            Instant start = now();
            return doTransferMoney(from, to, amount)    // 실제 돈 송금됨 (트랜잭션 충돌시 onError 시그널 반환)
               .retryBackoff(                           // onError 시 작업 재시도(재시도 20회, 최초 1밀리초후 재시작, 최대 50밀리초, 0.1 간격)
                  20, Duration.ofMillis(1),
                  Duration.ofMillis(50), 0.1
               )
               .onErrorReturn(TxResult.TX_CONFLICT)     // 재시도함에도 다 실패시 이것 리턴
               .doOnSuccess(result -> log.info("Transaction result: {}, took: {}",
                  result, Duration.between(start, now())));
         }));
   }

   private Mono<TxResult> doTransferMoney(      
      String from,      // 여기선 매개변수 일반 클래스 사용
      String to,
      Integer amount
   ) {
      return mongoTemplate.inTransaction().execute(session ->   // 새 트랜잭션 시작, ReactiveMongoOperations 의 session 인스턴스 사용
         session                                                // session 객체는 MongoDB 트랜잭션에 바인딩됨
            .findOne(queryForOwner(from), Wallet.class)         // 송금인 계좌 검색
            .flatMap(fromWallet -> session          
               .findOne(queryForOwner(to), Wallet.class)        // 수취인 계좌 검색
               .flatMap(toWallet -> {
                  if (fromWallet.hasEnoughFunds(amount)) {      // 잔액 확인 후 인출, 입금. 아직 디비에 저장은 안됨
                     fromWallet.withdraw(amount);               
                     toWallet.deposit(amount);

                     return session.save(fromWallet)            // 변경내용 저장 시작
                        .then(session.save(toWallet))
                        .then(ReactiveMongoContext.getSession())
                        // An example how to resolve the current session
                        .doOnNext(tx -> log.info("Current session: {}", tx))
                        .then(Mono.just(TxResult.SUCCESS));
                  } else {
                     return Mono.just(TxResult.NOT_ENOUGH_FUNDS);   // 잔액 부족
                  }
               })))
         .onErrorResume(e -> Mono.error(new RuntimeException("Conflict")))  // 통신 에러
         .last();
   }

   private Query queryForOwner(String owner) {              // MongoDB Criteria API 사용해 쿼리 실행하는 메서드
      return Query.query(new Criteria("owner").is(owner));
   }
}
```
- 트랜잭션에서 정확한 세션을 참조하는 것은 리액터 컨텍스트를 사용해 구현함
- ReactiveMongoTemplate.inTransaction() 은 새 트랜잭션을 시작해 이를 컨텍스트에 추가함
- ReactiveMongoContext.getSession() 사용시 세션 인스턴스 받아올 수 있음
- 하나의 쿼리에서 두개의 지갑 동시에 로드하고 한 번의 쿼리로 두 지갑 동시에 업데이트 하는 방식으로 개선 가능

### SAGA 패턴을 사용한 분산 트랜잭션
- 스프링 데이터가 MongoDB 4에 대해서만 리액티브 트랜잭션을 지원하고, 이것이 자바 트랜잭션 API와 호환되지 않음
  - 그래서 리액티브 마이크로서비스 내에서 분산 트랜잭션 구현할 수 이쓴ㄴ 유일한 옵션은 SAGA 패턴 사용 방법 뿐임(얘가 제일 좋다고함)

## 스프링 데이터 리액티브 커넥터
- 스프링 데이터 2.1에 포함된 커넥터 : MongoDB, Cassandra, Couchbase, Redis 의 4가지 Nosql
- WebClient 활용해 HTTP를 통해 통신하는 데이터 저장소라면 스프링데이터에서 지원할 가능성 높음

### MongoDB 리액티브 커넥터
- 훌륭하게 지원함(`spring-boot-start-data-mongodb-reactive` 스프링부트 스타터 모듈 추가하면 됨(리액티브 리포지토리 포함)
- ReactiveMongoRepository
  - ReactiveCrudRepository 모든 기능 상속
  - QBE(Query By Example, 쿼리를 작성하지 않고, 도메인 객체를 사용하여 데이터를 검색하는 방법) 지원 
  - @Query, @Meta 사용 가능
  - 캡드 컬렉션(Capped Collection)
    -  MongoDB에서 제공하는 특별한 유형의 컬렉션
    -  도큐먼트 입력 순서에 따라 조회됨
    -  원형 버퍼와 비슷함(크기 제한, 자동으로 오래된 데이터 삭제)
    -  인덱스 제한(fulltext의 경우 안됨)
    -  커서(Tailable Cursor) 지원
      - 클라이언트가 쿼리에서 모든 결과를 소비한 후에도 열려있음
      - 새 도큐먼트가 들어오면 새로운 도큐먼트를 반환
  - 다중 도큐먼트 트랜잭션 가능(WiredTiger 스토리지 엔진이 있는 복제본(샤드면안됨))

### Redis 리액티브 커넥터
- 다른 리액티브 커넥터와 달리 리액티브 리포지토리 제공 안함
- 따라서, ReactiveRedisTemplate 클래스가 Redis에 대한 리액티브 데이터 액세스의 핵심이 됨
- ReactiveRedisTemplate 은 ReactiveRedisOperations 인터페이스로 정의된 API를 구현하고, 직렬-역직렬화 로직 제공
- ReactvieRedisConnection 사용하면 Redis와 통신시 원시(raw) 바이트 버퍼 직접 처리 가능
- Redis 데이터 관리(저장, 검색) 외에도 pub-sub 방식의 채널 구독 지원
- Lettuce 드라이버와 통합되어 있음(Redis의 유일한 리액티브 자바 커넥터)
- Couchbase 제외한 모든 리액티브 커넥터에는 리액티브 방식의 헬스 인디케이터가 있음

## 제약 사항과 기대되는 개선 사항
