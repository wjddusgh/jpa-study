# 3 스트림의 새로운 표준 - 리액티브 스트림

## 모두를 위한 반응성
### API 불일치 문제
- 코드 작성시 여러 라이브러리 선택 가능
  - `CompletableStge` : 복잡하지 않은 비동기식 요청-응답 상호 작용 구현
  - `RxJava`
  - `ListenableFuture`
- 과도하게 많은 선택지는 시스템을 지나치게 복잡하게 만들 수 있다
  - 하나의 콜백을 다른 콜백으로, 또는 그 반대로 변환하기 위한 유틸리티 클래스를 만들어야함(자주 있는 일)
  - 이는 직접 개발자들이 작성하므로 버그 유입 가능성 큼
  - 스프링 5.xxx 부터는 호환성을 위한 메서드가 추가된게 있다고함
- 버전별 차이

### 풀 방식과 푸시 방식
- 리액티브 초기 단계에서 모든 라이브러리의 흐름은 소스 -> 구독자 push (pull 방식이 비효율적이었어서)
- `AsyncDatabaseClient` 메소드 활용해서 서비스 대기시간 줄여나감(단일 -> 리스트 -> stream 으로 바뀌네)

## 흐름제어
- Push 모델 채택 이유 : 요청 횟수 최소화해 전체 처리시간 최적화
- 하지만, 프로듀서가 컨슈머의 처리 능력을 무시하면 전반적이 시스템 안정성에 영향을 미칠 수 있기에 까다로움

### 느린 프로듀서와 빠른 컨슈머
- 순수 푸시모델은 동적으로 시스템 처리량 증가를 못시키므로 실제적 요구가 필요하다고함(?? 뭔말)

### 빠른 프로듀서와 느린 컨슈머
- 너무 컨슈머에 많이 전송하면 컴포넌트에 치명적 오류 발생가능성 up
- 직관적 솔루션 : Queue (컨슈머에 있을수도 있고, 프로듀서와 컨슈머 사이에 있을수도 있음)
  - 무제한 큐
    - 사이즈 제한이 없는 큐
    - 메시지 전달에 확신이 있다(모든 메시지는 전달되고, 처리됨)
    - 메모리 한도 도달하면 난리남
  - 크기가 제한된 드롭 큐
    - Memory Overflow 방지를 위해 큐가 가득차면 신규 유입 메시지를 무시하는 큐
    - 메시지 중요성이 낮을 때 사용
  - 크기가 제한된 블로킹 큐
    - 각 메시지가 중요한 경우(결제 요청 등) 메시지 삭제가 아닌 메시지 유입을 차단하는 큐
    - 시스템의 비동기 동작을 모두 무효화하는 문제가 있음( 가장 느린 컨슈머에 의해 시스템 전체가 느려짐)
- 순수 푸시모드는 배압 관리 표준화 기능 제공 안함
- 배치 처리를 사용해 처리 속도를 안정화 시킬수는 있음(적용 범위가 제한적)

## 해결책
빅테크 천재들이 JVM 커뮤니티에 표준 제공했다고 하네요
 
### 리액티브 스트림의 기본 스펙
- 기본 인터페이스
  - `Publisher`
  - `Subscriber`
  - `Subscription`
  - `Processor`
- Publisher 는 블로킹 방식으로 대기, Subscriber 요청시 데이터 생성 등 구현이 다양함
- Publisher 는 Subscriber 가 요청한 경우에만 원소의 새 부분을 보내도록 보장
- 하이브리드 푸시-풀 모델이 포함되어있음
  - 기존 풀 모델 처럼 스트림 이후 원하는 갯수만큼 요청 시 DB가 보내줌
  - 구독받는 중간(DB는 처리중인 상황)에 또 신청하면 이후에 추가로 또 요청의 응답 보내줌
  - 처음엔 응답이 늦게 도착할 수 있지만, 새로운 요청은 처리할 것이 없어 전체적인 처리 시간엔 거의 영향받지 않는다
- 푸시모델도 있다고 함(2^63-1 개씩 요청)
- 순수 풂 모델로 전환하려면 `Subscriber.onNext()` 를 호출시마다 한개씩 요청하면 된다고 함

### Processor 개념의 소개
- Publisher + Subcriber 혼합 형태임
- pub, sub 사이에 몇 가지 처리 단계를 추가하도록 설계됨
  - 커스텀 연산자로 구현할 수 있는 비즈니스 로직
  - 스트리밍 데이터의 추가 캐싱 등
- Processor 구성 시 단점
  - 비즈니스 흐름 복잡해지고, 모든 상황에 쉽게 맞는 재사용 가능한 연산자 만들수 없게됨
  - 별도의 Subscriber 관리 및 노력 필요  
  
