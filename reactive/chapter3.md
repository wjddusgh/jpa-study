# 3 스트림의 새로운 표준 - 리액티브 스트림

## 모두를 위한 반응성
### API 불일치 문제
- 코드 작성시 여러 라이브러리 선택 가능
  - `CompletableStge` : 복잡하지 않은 비동기식 요청-응답 상호 작용 구현
  - `RxJava`
  - `ListenableFuture`
- 과도하게 많은 선택지는 시스템을 지나치게 복잡하게 만들 수 있다
  - 하나의 콜백을 다른 콜백으로, 또는 그 반대로 변환하기 위한 유틸리티 클래스를 만들어야함(자주 있는 일)
  - 이는 직접 개발자들이 작성하므로 버그 유입 가능성 큼
  - 스프링 5.xxx 부터는 호환성을 위한 메서드가 추가된게 있다고함
- 버전별 차이

### 풀 방식과 푸시 방식
- 리액티브 초기 단계에서 모든 라이브러리의 흐름은 소스 -> 구독자 push (pull 방식이 비효율적이었어서)
- `AsyncDatabaseClient` 메소드 활용해서 서비스 대기시간 줄여나감(단일 -> 리스트 -> stream 으로 바뀌네)

## 흐름제어
- Push 모델 채택 이유 : 요청 횟수 최소화해 전체 처리시간 최적화
- 하지만, 프로듀서가 컨슈머의 처리 능력을 무시하면 전반적이 시스템 안정성에 영향을 미칠 수 있기에 까다로움

### 느린 프로듀서와 빠른 컨슈머
- 순수 푸시모델은 동적으로 시스템 처리량 증가를 못시키므로 실제적 요구가 필요하다고함(?? 뭔말)

### 빠른 프로듀서와 느린 컨슈머
- 너무 컨슈머에 많이 전송하면 컴포넌트에 치명적 오류 발생가능성 up
- 직관적 솔루션 : Queue (컨슈머에 있을수도 있고, 프로듀서와 컨슈머 사이에 있을수도 있음)
  - 무제한 큐
    - 사이즈 제한이 없는 큐
    - 메시지 전달에 확신이 있다(모든 메시지는 전달되고, 처리됨)
    - 메모리 한도 도달하면 난리남
  - 크기가 제한된 드롭 큐
    - Memory Overflow 방지를 위해 큐가 가득차면 신규 유입 메시지를 무시하는 큐
    - 메시지 중요성이 낮을 때 사용
  - 크기가 제한된 블로킹 큐
    - 각 메시지가 중요한 경우(결제 요청 등) 메시지 삭제가 아닌 메시지 유입을 차단하는 큐
    - 시스템의 비동기 동작을 모두 무효화하는 문제가 있음( 가장 느린 컨슈머에 의해 시스템 전체가 느려짐)
- 순수 푸시모드는 배압 관리 표준화 기능 제공 안함
- 배치 처리를 사용해 처리 속도를 안정화 시킬수는 있음(적용 범위가 제한적)

## 해결책
빅테크 천재들이 JVM 커뮤니티에 표준 제공했다고 하네요
 
### 리액티브 스트림의 기본 스펙
- 기본 인터페이스
  - `Publisher`
  - `Subscriber`
  - `Subscription`
  - `Processor`
- Publisher 는 블로킹 방식으로 대기, Subscriber 요청시 데이터 생성 등 구현이 다양함
- Publisher 는 Subscriber 가 요청한 경우에만 원소의 새 부분을 보내도록 보장
- 하이브리드 푸시-풀 모델이 포함되어있음
  - 기존 풀 모델 처럼 스트림 이후 원하는 갯수만큼 요청 시 DB가 보내줌
  - 구독받는 중간(DB는 처리중인 상황)에 또 신청하면 이후에 추가로 또 요청의 응답 보내줌
  - 처음엔 응답이 늦게 도착할 수 있지만, 새로운 요청은 처리할 것이 없어 전체적인 처리 시간엔 거의 영향받지 않는다
- 푸시모델도 있다고 함(2^63-1 개씩 요청)
- 순수 풂 모델로 전환하려면 `Subscriber.onNext()` 를 호출시마다 한개씩 요청하면 된다고 함

### Processor 개념의 소개
- Publisher + Subcriber 혼합 형태임
- pub, sub 사이에 몇 가지 처리 단계를 추가하도록 설계됨
  - 커스텀 연산자로 구현할 수 있는 비즈니스 로직
  - 스트리밍 데이터의 추가 캐싱 등
- Processor 구성 시 단점
  - 비즈니스 흐름 복잡해지고, 모든 상황에 쉽게 맞는 재사용 가능한 연산자 만들수 없게됨
  - 별도의 Subscriber 관리 및 노력 필요  
  
## 리액티브 스트림 기술 호환성 키트(TCK)
- 모든 리액티브 스트림 코드를 방어하고 지정된 규칙에 따라 구현을 테스트하는 도구
- 특정 동작을 확인할 수 있도록 자체 테스트 클래스를 제공
- `PublisherVerification`, `SubscriberBlackboxVerification`등의 클래스 제공

### JDK 9
- 스트림 api가 pull 모델만 제공하고 push 모델이 누락됐다는 점에서 확인 가능
- 자바 스트림 api는 병렬 실행이 가능하도록 Iterator를 개량한 Spliterator 사용
- Iterator은 push 용도로 설계된 것이 아니라 풀링 용도로 설계됨(Iterator.next()를 통해)
- Spliterator는 tryAdvance() 사용, Iterator의  hasNext(), next() 조합한 것
- 이들은 모두 JDK 9+ 의 Flow 클래스를 기반으로 함(책 기준 아직 리액티브 라이브러리에 많이 안쓰이고 있다함)

## 리액티브 스트리을 활용한 비동기 및 병렬 처리
- 리액티브 스트림 api는 Pub가 생성하고 Sub가 소비한 모든 신호는 처리중에 논블로킹 + 방해X 여야한다고 명시함
- ??여기 이해 잘 안됨
- 비동기 처리 경계중 어떤 부분이 흐름 처리 부분과 연결돼야 하는가
  - 처리 흐름이 소스 리소스에 연결돼있고 모든 작업이 소스와 동일한 경계 내에서 발생하는 경우
    - 모든 데이터가 하나씩 동기식으로 처리됨
    - 원본 리소스가 목적지 리소스보다 적게 로드될 때 유효
  - 비동기 경계의 처리가 목적지 또는 컨슈머 스레드에 있으며, 메시지 생성이 CPU를 많이 사용하는 작업의 경우
  - 메시지 생산과 소비가 모두 CPU 집약적인 작업인 경우 중간 변환을 별개의 스레드에서 실행
    - 변환이 가장 큰 리소스를 소비할 때

## 리액티브 전망의 변화
### RxJava의 변화
- 하나의 리액티브 타입을 다른 리액티브 타입으로 쉽게 변환해주는 추가 모듈을 제공
  - Observable<T> 를 Publisher<T>로 변환하고 rx.Subscriber<T>를 org.reactivestreams.Subscriber<T>로 변환 등
  - `RxReactiveStreams` 클래스를 사용하여 변환
- 이전 버전과의 호환성 때문에 리액티브 스트림 스펙을 직접 구현하진 못했음
- RxJava 2.x 버전부터는 Observable(여기선 푸시 전용 스트림)과 함께 `Flowable` 지원
  - Observable과 동일한 api를 제공하지만, `org.reactivestreams.Pulisher` 상속함
  
### 스프링에선 리액터 프로젝트가 중요해보임  
