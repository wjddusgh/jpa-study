# 스프링을 이요한 리액티브 프로그래밍 -기본 개념

## 리액티브를 위한 스프링 프레임워크의 초기 해법
### 관찰자(Observer) 패턴
- GoF 디자인 패턴 중 하나
- 관찰자라고 불리는 자손의 리스트를 가지고 있는 주체(subject) 필요
  - 이벤트를 발생시키는 역할
  - MVC 패턴의 중요한 부분
  - 런타임에 객체 사이에 일대다 의존성 등록 가능 -> 결합도 낮춤

### @EventListener를 사용한 발행-구독 패턴
- 이벤트 처리를 위한 api 제공
- @EventlListner 애노테이션, ApplicationEventPublisher 클래스 제공
- 관찰자 패턴과 달리 pub-sub은 서로를 알 필요가 없음
- 토픽 기반 시스템의 구독자는 관심 토픽에 게시된 모든 메시지 수신
- 조건 속성은 스프링 표현 언어(SpEL) 사용 처리 가능하게함
### 평가
- 이 메커니즘은 응용 프로그램 수명주기 이벤트 처리를 위해 도입됨
- 고부하, 고성능 시나리오를 위한게 아님
- @EventListener 는 오류처리에 대한 구현을 별도의 커스텀 상속 구조로 정의해야함
- 비동기적 브로드캐스팅을 위해 스레드 풀을 사용하는건 진정한 비동기적 리액티브 접근법이 아님

## 리액티브 프레임워크 RxJava(Reactive Extensions)
- 표준 라이브러리였던 자바 진영 리액티브 프로그래밍의 개척자
- 관찰자 패턴 + 반복자 패턴 + 함수형 프로그래밍 조합

### 관찰자 + 반복자 = 리액티브 스트림
- 리액티브 Observable 클래스는 관찰자 패턴의 subject와 일치함 -> 이벤트 발생시키는 소스 역할
  - onNext() 로 여러번 호출한 다음 onComplete() 혹은 onError() 호출시켜 실행종료
  - 재사용 가능한 클래스 
- Subcriber 추상 클래스는 Observer 인터페이스를 구현하고 이벤트 소비
  
## 스트림 변환과 마블 다이어그램
- Rxjava의 모든 기능은 연산자에 의해 구현된다고 할 수 있음
### Map 연산자
`<R> Observable<R> map(Func1<T, R> func)`
- 마블 다이어그램 : 스트림 변환을 시각적으로 표현함
### Filter 연산자
### Count 연산자
### Zip 연산자
- 두 개의 병렬 스트림 값을 결합
- 동작이 복잡

## 리액티브 라이브러리의 간략한 역사
- Microsoft 내부에서 시작 (Rx. 라이브러리) -> Rx.Net
- 마소 외부에서도 Rx 퍼짐 -> RxJava
- RxJava는 현재 일부 NoSQL 자바 드라이버에서 사용됨
- RxAndroid도 등장
- 이쪽의 진짜 기여자는 NodeJS 와 그 커뮤니티

## 리액티브의 전망
- ? 좋다는거같다
