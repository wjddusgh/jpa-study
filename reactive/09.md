# 09 리액티브 애플리케이션 테스트하기

# 리액티브 스트림을 테스트하기 어려운 이유
- 테스트 피라미드 제안
  1. unit test
  2. integration test
  3. ui test
- 비동기식은 반환된 값이 올바른지 확인하는 간단한 방법 없음

## StepVerifier를 이용한 리액티브 스트림 테스트
- StepVerifier 가 제공하는 연쇄형 api 사용 시 어떤 종류의 Publisher 라도 스트림 검증을 위한 플로 만들 수 있다
- 리액터 테스트 모듈 다룰 것

### StepVerifier의 핵심 요소
- Publisher 검증하는 핵심 메서드
  - StepVerifier \<T\> create(Publisher source)
    - 빌더 기법을 통해 검증 프로세스 중에 이벤트가 발생하는 순서 정의 가능
    - 이를 통해 Publisher 의 원소나 이벤트 수를 확인 가능
    - 엄청난 규모의 스트림 검증은 매우 어려움
    - 특정 양 생성확인 -> expectNextCount()
    - consumeRecordedWith() 사용 시 원소를 람다로 사용 가능(recordWith() 먼저 사용해야함)
      - 보통은 recordWith(ArrayList::new), 멀티 스레드 Publisher 경우 동시 액세스 지원해야 하므로 recordWith(ConcurrentLinkedQueue::new) 스레드 세이프 함
    - expectNextMatches() : 사용자가 matcher 를 직접 정의해 사용(expectNext() 는 .equals() 사용함)
    - assertNext() 도 존재, 예외를 발생시키는 Consumer 허용
    - 모든 AssertionError 는 .verify() 에 의해 캡처되어 다시 예외 발생시킴
    - 식별되지 않는 오류 -> expectError() 사용, 파라미터로 익셉션 넣어 오류 특정도 가능
    - consumeErrorWith() 사용 시 Throwable과 직접 상호작용 가능
```java
  Stepverifier
  .create(Flux.just("foo", "bar"))
  .expectSubscription()
  .expectNext("foo")
  .expectNext("bar")
  .expectComplete()
  .verify();
```
### StepVerifier를 이용한 고급 테스트
- Publisher 테스트의 첫 단계 : 무한한지 확인
  - 스트림이 Subscriber.onComplete() 호출 안한다는것 -> 앞에서의 테스트 기법 못쓴다는 것(테스트가 프로세스 종료될 때까지 블로킹됨)
- 해결법 : StepVerifier 가 몇가지 기댓값 확인하면 소스에서 구독을 취소하는 api 제공 -> thenCancel()
- Publisher 배압 확인
  - onBackpressureBuffer() 연산자로 다운스트림 보호
  - thenRequest() 로 구독자의 요청 수량 제어 가능
    - 오버플로 오류 만들 수 있음(많이요청해서)
-  특정 검증 후에 추가 작업 실행 할수 있는 기능 : then()
- TestPublisher
  - 리액터 코어 라이브러리 테스트 패키지에 있는 Publisher 의 구현체
  - 테스트 목적으로 onNext(), onComplete(), onError() 이벤트 직접 기동 가능
