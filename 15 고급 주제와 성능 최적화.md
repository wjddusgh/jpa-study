# 15.1 예외 처리
## 15.1.1 JPA 표준 예외 정리
- JPA 표준 예외들은 `javax.persistence.PersistenceException` 의 자식 클래스이고, 이것은 `RuntimeException`의 자식이다
- 런타임에러의 자식으므로 JPA 예외는 모두 언체크 예외다
- JPA 표준 예외는 트랜잭션 롤백을 표시 하는지 안하는지로 나눠진다
  - 트랜잭션 롤백 표시 예외 : 심각한 예외이므로 복구해선 안된다
  - 트랜잭션 롤백 표시 안하는 예외 : 개발자가 트랜잭션을 커밋할지 롤백할지를 판단하면 된다

## 15.1.2 스프링 프레임워크의 JPA 예외 변환
- 서비스 계층에서 데이터 접근 계층의 구현 기술에 직접 의존하는것은 별로다
- 그래서 스프링은 JPA 예외를 추상화해서 개발자에게 제공

## 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
- `PersistenceExceptionTranslationPostProcessor` 를 스프링 빈으로 등록하면 변환이 적용된다
  - `@Repository` 사용한 곳에 예외 변환 AOP를 적용해서 추상화 시켜주는것
  - 적용해놓고 JPA 예외 받고싶으면 레포지토리 메소드에 `throws JPA 예외` 붙이면 된다

## 15.1.4 트랜잭션 롤백 시 주의사항
- 트랜잭션 롤백은 DB 만 롤백하고, 자바 객체까지 롤백해주지는 않는다
- 그래서 트랜잭션 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험
  - 새로운 영속성 컨텍스트를 생성하거나, `em.clear()` 호출해서 초기화한 다음에 사용(스프링은 알아서 해주는듯) 

# 15.2 엔티티 비교
- 영속성 컨텍스트에는 1차 캐시가 있고, 이것은 영속성 컨텍스트와 생명주기를 같이 한다
- 1차 캐시 덕분에 변경 감지기능 도 동작하고, 얘로 같은 영속성에서 조회하면 동일성을 만족하는, 주소값이 같은 인스턴스 반환
## 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교
- 동일성 : == 비교가 같다
- 동등성 : equals() 비교가 같다
- 데이터베이스 동등성 : @Id인 데이터베이스 식별자가 같다
### 참고, 테스트 클래스에 `@Transaction` 적용 시 테스트 끌날 때 트랜잭션을 커밋하지 않고 강제로 롤백한다. 단, 롤백 시 영속성 컨텍스트를 플러시하지 않는다 로그 확인하고싶던가 하면 em.flush()를 통해 직접 플러시하자

## 15.2.2 영속성 컨텍스트가 다를 때 엔티티 비교
- 테스트 클래스에 `@Transaction`이 없다면 테스트는 실패
- 서비스 계층에서 트랜잭션이 시작되는데, 서비스 계층 종료 후 테스트 클래스에서 영속성 컨텍스트는 종료된 상태니 엔티티는 준영속 상태라서 새로운 영속성 컨텍스트가 시작되고, 두 엔티티는 서로 동일성을 못지킴

- 결국, 엔티티 비교는 비즈니스 키를 활용한 동등성 비교로 하는게 좋을것

# 15.3 프록시 심화 주제
## 15.3.1 영속성 컨텍스트와 프록시
- 영속성 컨텍스트는 프록시로 조회된 엔티티는 나중에 실제 값 가져와도 비교를 처음 조회된 프록시로 한다
- 프록시객체를 확인하기 전에 실제 값을 가져온다면 값 비교를 그대로 실제 엔티티로 한다
- 그래서 프록시 객체여도 같은 영속성 컨텍스트에서는 동일성 비교 가능

## 15.3.2 프록시 타입 비교
- 프록시는 원본 엔티티를 상속 받아서 만들어지므로 타입 비교는 `==`가 아닌 `instanceof` 를 사용해야 한다
## 15.3.3 프록시 동등성 비교
- ide나 외부 라이브러리를 사용해 구현한 equals() 메소드로 프록시 객체 비교시 문제 발생 가능성 있다
  1. 내부적으로 `==`를 통한 동일성 비교를 할 경우 : instanceof 사용하자
  2. 아직 값이 없는 프록시객체의 멤버변수에 직접 접근할 경우 : 접근자 메소드를 사용하자
## 15.3.4 상속관계와 프록시
- 프록시를 부모 타입으로 조회하면 부모를 기반으로 프록시가 생성되어 instanceof 연산을 할 수 없고, 다운캐스팅도 안된다
- 해결방법
  1. JPQL로 대상 직접 조회
  2. 프록시 벗기기(unProxy())
  3. 비지터 패턴 사용 

# 15.4 성능 최적화
## 15.4.1 N+1 문제
- JPA 사용 시 성능 상 제일 주의해야 하는 것
### 즉시 로딩과 N+1
- 특정 엔티티를 `em.find()`로 조회하면 즉시 로딩으로 설정한 다른 참조 엔티티도 함께 조회한다
- JPA는 JPQL을 분석해서 SQL 생성하는데 로딩전략은 신경 안쓰고 생성하기 때문에 특정 엔티티의 갯수만큼 참조 엔티티도 각각 조회하게 된다
```sql
select * from A // 여기서 A의 엔티티 갯수가 n개라면

select * from B where a_id=?  // 이 구문이 n개만큼 실행, 그래서 N+1 문제
```
### 지연 로딩과 N+1
- 지연 로딩 시 JPQL을 통해 SQL 생성하면 `select * from A` 하나만 실행하여 당장은 N+1 문제 발생 X
- 이후 비즈니스 로직에서도 하나만 조회한다면 문제가 생기지 않는다
- 모든 회원에 대해 조회한다면? (ex. findAll(), 순회 등) 여기서 나머지 N번만큼 조회 발생
- N+1 문제 해결법은?
### 페치 조인 사용
- 가장 일반적인 해결 방법
- JPQL에 `join fetch` 넣는다
- 일대다 조인 시 중복된 결과를 가져올 수 있으므로 `distinct` 사용해서 중복 제거하는게 좋다

### 하이버네이트 @BatchSize
- `@BatchSize` 어노테이션 사용 시 연관된 엔티티 조회할 때 지정한 size만큼 SQL의 `IN` 절을 사용해서 조회한다 (ex. size가 5인데 특정 엔티티 갯수가 10개면 SQL 두번 추가 실행)
```sql
select * from A
where b_id in (
  ?,  ?,  ?,  ?,  ?
)
```
- `hibernate.default_batch_fetch_size` 속성 사용시 애플리케이션 전체에 기본으로 @BatchSize 적용시킬 수 있다

### 하이버네이트 @Fetch(FetchMode.SUBSELECT)
- 페치모드를 SUBSELECT로 사용하면 연괸 데이터 조회 시 서브쿼리를 사용해서 N+1 문제를 해결한다
### N+1 정리
- 즉시 로딩은 많은 엔티티를 로딩해야 하는 상황이 자주 발생하고, 성능최적화가 어렵다
- 그러므로 지연 로딩과 페치조인을 조합해 사용하자

## 15.4.2 읽기 전용 쿼리의 성능 최적화
- 영속성 컨텍스트는 1차캐시, 변경 감지등 장점이 있지만, 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다
- 이 때, 읽기 전용으로 엔티티 조회시 메모리 사용량을 최적화 할 수 있다
- JPQL `select o from Order o` 를 최적화 해보자
### 스칼라 타입으로 조회
- `select o.id, o.name. o.price from Order o`
- 스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다
### 읽기 전용 쿼리 힌트 사용
- `query.setHint("org.hibernate.readOnl", true);`
- 읽기 전용이므로 영속성 컨텍스트는 스냅샷을 보관하지 않는다. 단, 스냅샷이 없으므로 엔티티를 수정해도 데이터베이스에 반영되지 않는다
### 읽기 전용 트랜잭션 사용
- `@Transactional(readOnly = true)`
- 스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 `MANUAL`로 설정하게 되고, 이러면 강제로 플러시 하지 않는 한 플러시가 일어나지 않는다
- 트랜잭션이긴 하므로 트랜잭션 시작, 로직수행, 커밋의 과정은 이루어진다
- `MANUAL`은 하이버네이트 세션 설정에만 있는 모드이다
- 스프링에선 이게 제일 편리하다
### 트랜잭션 밖에서 읽기
- 트랜잭션 밖에서 수정은 영속성 컨텍스트에 반영이 안되므로 읽기전용에서만 하는 것
- 스프링 : `@Transactional(propagation = Propagation.NOT_SUPPORTED)
- J2EE : `@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)`

## 15.4.3 배치 처리
- 엄청난 양의 배치 처리를 진행하기 위해 엔티티를 계속 조회하면 영속성 컨텍스트 메모리 부족이 생길수도 있다
- 2차캐시도 사용안하도록 조심하라는데 다음 챕터에 나온다고 함
### JPA 등록 배치
- 일정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 초기화 해줘야함
### JPA 수정 배치
- 페이징 처리 : N건 단위만큼 한번에 조회해서 처리하고, 플러시와 초기화를 하는 방법
- 하이버네이트 scroll 사용 : JDBC 커서를 사용하는 방법
  - scroll은 하이버네이트 전용 기능이므로 먼저 `em.unwrap()`을 통해 하이버네이트 세션을 구한다 
  - 다음으로 쿼리를 조회하면서 `scroll()` 메소드로 `ScrollableResults` 객체 반환, `next()` 호출시 엔티티를 하나씩 조회 가능하다
- 하이버네이트 무상태 세션 사용 : 영속성 컨텍스트도, 2차 캐시도 사용하지 않는 방법
  - 영속성 컨텍스트가 없으므로 플러시나 초기화를 안해줘도 되지만, 수정 시 무상태 세션이 제공하는 update()를 직접 호출해야한다

## 15.4.4 SQL 쿼리 힌트 사용
- `addQueryHint()` 사용
- 지금도인지는 모르지만 오라클 이외의 DB 벤더는 `org.hibernate.dialect.Dialect`에 있는 `getQueryHintString()` 오버라이딩 해서 사용해야함
## 15.4.5 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
- 네트워크 호출 한번은 단순한 메소드 수만번 호출보다 비용이 크다
- JPA 구현체 마다 SQL 배치 최적화 전략은 조금씩 다르다
- 하이버네이트는 `hibernate.jdbc.batch_size` 를 설정하면 된다. 다만, 같은 SQL만 모으고 중간에 다른 SQL이 나오면 배치로 묶지않는다
- 식별자 생성 전략이 IDENTITY라면 식별자를 얻어와야하므로 무조건 persist()마다 SQL 호출이 있고, 최적화 불가능
- 이거의 진짜 장점은 데이터베이스 락(Lock)이 최소화 된다는 점
