# 15.1 예외 처리
## 15.1.1 JPA 표준 예외 정리
- JPA 표준 예외들은 `javax.persistence.PersistenceException` 의 자식 클래스이고, 이것은 `RuntimeException`의 자식이다
- 런타임에러의 자식으므로 JPA 예외는 모두 언체크 예외다
- JPA 표준 예외는 트랜잭션 롤백을 표시 하는지 안하는지로 나눠진다
  - 트랜잭션 롤백 표시 예외 : 심각한 예외이므로 복구해선 안된다
  - 트랜잭션 롤백 표시 안하는 예외 : 개발자가 트랜잭션을 커밋할지 롤백할지를 판단하면 된다

## 15.1.2 스프링 프레임워크의 JPA 예외 변환
- 서비스 계층에서 데이터 접근 계층의 구현 기술에 직접 의존하는것은 별로다
- 그래서 스프링은 JPA 예외를 추상화해서 개발자에게 제공

## 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
- `PersistenceExceptionTranslationPostProcessor` 를 스프링 빈으로 등록하면 변환이 적용된다
  - `@Repository` 사용한 곳에 예외 변환 AOP를 적용해서 추상화 시켜주는것
  - 적용해놓고 JPA 예외 받고싶으면 레포지토리 메소드에 `throws JPA 예외` 붙이면 된다

## 15.1.4 트랜잭션 롤백 시 주의사항
- 트랜잭션 롤백은 DB 만 롤백하고, 자바 객체까지 롤백해주지는 않는다
- 그래서 트랜잭션 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험
  - 새로운 영속성 컨텍스트를 생성하거나, `em.clear()` 호출해서 초기화한 다음에 사용(스프링은 알아서 해주는듯) 

# 15.2 엔티티 비교
- 영속성 컨텍스트에는 1차 캐시가 있고, 이것은 영속성 컨텍스트와 생명주기를 같이 한다
- 1차 캐시 덕분에 변경 감지기능 도 동작하고, 얘로 같은 영속성에서 조회하면 동일성을 만족하는, 주소값이 같은 인스턴스 반환
## 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교
- 동일성 : == 비교가 같다
- 동등성 : equals() 비교가 같다
- 데이터베이스 동등성 : @Id인 데이터베이스 식별자가 같다
### 참고, 테스트 클래스에 `@Transaction` 적용 시 테스트 끌날 때 트랜잭션을 커밋하지 않고 강제로 롤백한다. 단, 롤백 시 영속성 컨텍스트를 플러시하지 않는다 로그 확인하고싶던가 하면 em.flush()를 통해 직접 플러시하자

## 15.2.2 영속성 컨텍스트가 다를 때 엔티티 비교
- 테스트 클래스에 `@Transaction`이 없다면 테스트는 실패
- 서비스 계층에서 트랜잭션이 시작되는데, 서비스 계층 종료 후 테스트 클래스에서 영속성 컨텍스트는 종료된 상태니 엔티티는 준영속 상태라서 새로운 영속성 컨텍스트가 시작되고, 두 엔티티는 서로 동일성을 못지킴

- 결국, 엔티티 비교는 비즈니스 키를 활용한 동등성 비교로 하는게 좋을것

# 15.3 프록시 심화 주제
## 15.3.1 영속성 컨텍스트와 프록시
- 영속성 컨텍스트는 프록시로 조회된 엔티티는 나중에 실제 값 가져와도 비교를 처음 조회된 프록시로 한다
- 프록시객체를 확인하기 전에 실제 값을 가져온다면 값 비교를 그대로 실제 엔티티로 한다
- 그래서 프록시 객체여도 같은 영속성 컨텍스트에서는 동일성 비교 가능

## 15.3.2 프록시 타입 비교
- 프록시는 원본 엔티티를 상속 받아서 만들어지므로 타입 비교는 `==`가 아닌 `instanceof` 를 사용해야 한다
## 15.3.3 프록시 동등성 비교
- ide나 외부 라이브러리를 사용해 구현한 equals() 메소드로 프록시 객체 비교시 문제 발생 가능성 있다
  1. 내부적으로 `==`를 통한 동일성 비교를 할 경우 : instanceof 사용하자
  2. 아직 값이 없는 프록시객체의 멤버변수에 직접 접근할 경우 : 접근자 메소드를 사용하자
## 15.3.4 상속관계와 프록시
- 프록시를 부모 타입으로 조회하면 부모를 기반으로 프록시가 생성되어 instanceof 연산을 할 수 없고, 다운캐스팅도 안된다
- 해결방법
  1. JPQL로 대상 직접 조회
  2. 프록시 벗기기(unProxy())
  3. 비지터 패턴 사용 
