# 15.1 예외 처리
## 15.1.1 JPA 표준 예외 정리
- JPA 표준 예외들은 `javax.persistence.PersistenceException` 의 자식 클래스이고, 이것은 `RuntimeException`의 자식이다
- 런타임에러의 자식으므로 JPA 예외는 모두 언체크 예외다
- JPA 표준 예외는 트랜잭션 롤백을 표시 하는지 안하는지로 나눠진다
  - 트랜잭션 롤백 표시 예외 : 심각한 예외이므로 복구해선 안된다
  - 트랜잭션 롤백 표시 안하는 예외 : 개발자가 트랜잭션을 커밋할지 롤백할지를 판단하면 된다

## 15.1.2 스프링 프레임워크의 JPA 예외 변환
- 서비스 계층에서 데이터 접근 계층의 구현 기술에 직접 의존하는것은 별로다
- 그래서 스프링은 JPA 예외를 추상화해서 개발자에게 제공

## 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
- `PersistenceExceptionTranslationPostProcessor` 를 스프링 빈으로 등록하면 변환이 적용된다
  - `@Repository` 사용한 곳에 예외 변환 AOP를 적용해서 추상화 시켜주는것
  - 적용해놓고 JPA 예외 받고싶으면 레포지토리 메소드에 `throws JPA 예외` 붙이면 된다

## 15.1.4 트랜잭션 롤백 시 주의사항
- 트랜잭션 롤백은 DB 만 롤백하고, 자바 객체까지 롤백해주지는 않는다
- 그래서 트랜잭션 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험
  - 새로운 영속성 컨텍스트를 생성하거나, `em.clear()` 호출해서 초기화한 다음에 사용(스프링은 알아서 해주는듯) 

# 15.2 엔티티 비교
- 영속성 컨텍스트에는 1차 캐시가 있고, 이것은 영속성 컨텍스트와 생명주기를 같이 한다
- 1차 캐시 덕분에 변경 감지기능 도 동작하고, 얘로 같은 영속성에서 조회하면 동일성을 만족하는, 주소값이 같은 인스턴스 반환
