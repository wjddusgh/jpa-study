# 16 트랜잭션과 락, 2차 캐시
# 16.1 트랜잭션과 락
## 16.1.1 트랜잭션과 격리 수준
- 트랜잭션의 ACID
  - Atomicity(원자성) : 모두 성공 아닐거면 모두 실패
  - Consistency(일관성) : 일관성 있는 데이터베이스 상태 유지
  - Isolation(격리성) : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치면 안됨
  - Durability(지속성) : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 함
- 이 중 격리성을 지키려면 동시성 처리 성능이 매우 나빠져서 ANSI 표준은 트랜잭션 격리 수준을 4단계로 나눔
- 격리 수준 단계
  - READ UNCOMMITTED : 커밋하지 않은 데이터를 읽을 수도 있다 -> DIRTY READ 발생 가능
  - READ COMMITTED : 커밋한 데이터만 읽을수 있지만, 반복된 읽기가 안될수도 있다
  - REPEATABLE READ : PHANTOM READ 발생 가능 -> 다중 조회시 조회결과 COUNT가 다를 수 있다
  - SERIALIZABLE : 문제점 안발생, 하지만 느려터짐
- 격리 수준에 따른 문제점
  - DIRTY READ
  - NON-REPEATABLE READ
  - PHANTOM READ 
- 보통 READ COMMITTED 격리 수준을 기본으로 사용한다
- 또한, 최근 데이터베이스들이 더많은 도잇성 처리를 위해 락보다는 MVCC를 사용한다고 한다

## 16.1.2 낙관적 락과 비관적 락 기초
- 영속성 컨텍스트(1차 캐시)를 적절히 활용하면 READ COMMITTED 여도 REPEATABLE READ가 가능하다. 단, 스칼라 읽기라면 1차 캐시 사용 못하므로 안된다
- JPA는 READ COMMITTED 정도를 가정하는데, 더 높은 격리 수준이 필요하면 낙관적 락 과 비관적 락 중 하나를 사용하면 된다
### 낙관적 락
- 트랜잭션은 대부분 충돌이 나지 않는다고 가정하는 방법
- JPA가 제공하는 버전 관리 기능을 사용(애플리케이션이 제공하는 락)
- 트랜잭션을 커밋하기 전까지 충돌을 알 수 없다
### 비관적 락
- 트랜잭션의 충돌이 난다고 가정하고 락을 걸고보는 방법
- 데이터베이스가 제공하는 락 기능을 사용
- 대표적으로 select ~ for update 구문이 있다
### 두 번의 갱신 분실 문제(second lost updates problem)
- 하나의 갱신이 진행 중에 다른 갱신도 발생하고 후에 먼저 커밋한 갱신이 사라지는 문제
- 이건 데이터베이스 트랜잭션의 범위를 넘어섬
- 이 때 3가지 선택 방법이 존재
  - 마지막 커밋만 인정하기 (기본적인 선택 방법)
  - 최초 커밋만 인정하기 (@Version으로 구현 용이)
  - 충돌하는 갱신 내용 병합하기 (우아하지만 개발자가 병합 방법을 제공해야함)

## 16.1.3 @Version
- JPA가 제공하는 낙관적 락을 사용하려면 @Version 애노테이션을 사용하여 버전 관리 기능을 추가해야 한다
- @Version 적용 가능 타입 (래퍼 클래스의 원시 타입도 가능)
  - Long
  - Integer
  - Short
  - Timestamp 
- 적용 시 엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가하며, 조회 시점과 버전이 다르면 예외 발생 (최초 커밋만 인정된다)
- 연관관계 필드는 외래 키의 주인 필드가 수정될 때만 버전 증가
- 벌크 연산은 버전을 무시함(버전 증가 안함)
### 버전 정보 비교 방법
- 엔티티 검색 조건에 버전 정보 추가

## 16.1.4 JPA 락 사용
- `em.lock()`, `em.find()`, `em.refresh()`, `query.setLockMode()`, `@NamedQuery` 에 락을 걸 수 있다
## 16.1.5 JPA 낙관적 락
- @Version 사용
## 16.1.6 JPA 비관적 락
- `LockMode.PESSIMISTIC_WRITE` 주로 사용 (select ~ for update 사용)
- 스칼라 타입 조회에도 사용 가능
- 데이터 수정 즉시 트랜잭션 충돌을 감지할 수 있다

## 16.1.7 비관적 락과 타임아웃
- 비관적 락 사용 시 락을 획득할 때 까지 트랜잭션이 대기한다
- 타임아웃시간이 존재하고, 시간을 넘기면 예외 발생

# 16.2 2차(공유) 캐시
## 16.2.1 1차 캐시와 2차 캐시
- 일반적인 웹 애플리케이션 환경은 트랜잭션의 시작부터 종료까지만 1차 캐시가 유효함(OSIV를 사용해도 동일)
### 2차 캐시
- 애플리케이션을 종료할 때까지 캐시가 유지됨(분산 캐시나 클러스터링 환경의 캐시는 더 오래 유지될 수도 있다)
- 2차 캐시는 동시성을 극대화하기 위해 캐시한 객체를 직접 반환하지 않고 복사본을 만들어서 반환한다(직접 반환시 여러 곳에서 같은 객체를 수정할 수도 있음, 락에 비해 복사는 비용이 낮음)
### 2차 캐시의 특징
- 영속성 유닛 범위의 캐시
- 복사본을 만들어서 반환
- 데이터베이스 기본 키를 기주으로 캐시하지만, 영속성 컨텍스트가 다르다면 동일성(==)을 보장하지 않는다
## 16.2.2 JPA 2차 캐시 기능
### 캐시 모드 설정
- `@Cacheable` 추가
### 캐시 모드 종류
- ALL : 모든 엔티티를 캐시함
- NONE : 캐시를 사용하지 않음
- ENABLE_SELECTIVE : Cacheable(true)로 설정된 엔티티만 캐시 적용
- DISABLE_SELECTIVE : 모든 엔티티를 캐시하지만, Cacheable(false)로 설정된 엔티티는 캐시 안함
- UNSPECIFIED : JPA 구현체가 정의한 설정을 따름
### 캐시 조회 모드, 저장 방식 모드 설정
- 캐시 조회
  - USE : 캐시에서 조회, 기본값
  - BYPASS : 디비에서 직접 조회
- 캐시 보관
  - USE : 조회한 데이터 캐시에 저장, 이미 있다면 최신상태로 갱신하지 않음, 기본값
  - BYPASS : 캐시에 저장 안함
  - REFRESH : USE에 추가로 조회한 엔티티가 캐시에 있어도 최신 상태로 다시 캐시함  
### JPA 캐시 관리 API
- Cache 인터페이스 제공, `EntityManagerFactory.getCache()` 메소드를 통해 얻어옴

## 16.2.3 하이버네이트와 EHCACHE 적용
### 하이버네이트가 지원하는 캐시 종류
- 엔티티 캐시 : 엔티티 단위로 캐시, 식별자로 엔티티 조회하거나 컬렉션이 아닌 연관된 엔티티 로딩 시 사용
- 컬렉션 캐시 : 엔티티와 연관된 컬렉션을 캐시, 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시(하이버네이트 기능)
- 쿼리 캐시 : 쿼리와 파라미터 정보를 키로 사용해서 캐시, 결과가 엔티티면 식별자 값만 캐시(하이버네이트 기능)  
