# 13. 검색어 자동완성 시스템

## 1단계) 문제 이해 및 설계 범위 확정

### 요구사항
- 빠른 응답 속도(100ms 이내)
- 연관성 : 자동완성되어 출력되는 검색어는 사용자가 입력한 단어와 연관된 것이어야함
- 정렬 : 인기도 등의 순위 모델에 의해 정렬되어야 함
- 규모 확장성
- 고가용성

### 개략적 규모 추정
- DAU: 1000만 명
- 평균적으로 사용자는 매일 10건 검색 수행
- 질의마다 평균 20 바이트
  - 문자 인코딩 : ASCII(문자당 1바이트)
  - 질의문은 평균 5개 단어(단어당 평균 5글자)
- 대략 24,000 qps 발생
- 질의 중 20% 정도는 신규 검색 -> 매일 0.4GB 신규데이터 추가

## 2단계) 개략적 설계안 제시 및 동의 구하기
### 데이터 수집 서비스
사용자가 입력한 질의를 실시간으로 수집하는 시스템
- 빈도 테이블에 질의 문장과 빈도를 채움
### 질의 서비스
주어진 질의에 N 개의 인기 검색어를 정렬해 내놓는 서비스
- 빈도 테이블에서 질의와 가장 관련된 N개 뽑아야 함
- `SELECT * FROM table Where query LIKE `prefix%` ORDER BY frequency DESC LIMIT N` 도 가능하겠지만 데이터 양 많아지면 병목이 될 수 있다

## 3단계) 상세 설계

## 트라이 자료구조
- 트라이
  - 트리 형태의 자료구조
  - 루트 노드는 빈 문자열을 나타냄
  - 각 노드는 글자 하나를 저장하며, 26개(알파벳 모두)의 자식 노드를 가질 수 있다
  - 각 트리 노드는 하나의 단어, 또는 prefix 문자열을 나타낸다
- 시간 복잡도
  - p: prefix 길이
  - n: 트라이 안에 있는 노드 개수
  - c: 주어진 노드의 자식 노드 개수
  - 가장 많이 사용된 질의어 k 개 찾는 시간복잡도
    - 해당 prefix 표현하는 노드 찾기. O(p)
    - 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드 찾기. O(c)
    - 유효 노드들을 정렬하여 가장 인기있는 검색어 k개 찾기. O(clogc)
    - 총 O(p) + O(c) + O(clogc)
    - 최악의 경우 전체 트라이를 다 검색해야 함
  - 시간복잡도 해결책
    - prefix 최대 길이 제한
    - 각 노드에 인기 검색어 캐시
### prefix 최대 길이 제한
사용자가 검색창에 긴 검색어 입력하는 일은 거의 없으므로 p 값을 작은 정숫값으로 제한한다. 
- O(p) -> O(1) 로
### 노드에 인기 검색어 캐시
각 노드에 k개의 인기 검색어 캐시 해두면 전체 트라이 검색하는 일을 방지할 수 있다
- 노드당 저장할 공간은 늘지만, 빠른 응답속도 요구사항이 필요할 때는 충분히 희생할 가치가 있다
- 유효 노드 찾기: O(1), 인기 검색어 찾기: O(1)

## 데이터 수집 서비스
지금까지의 설계안은 사요자가 검색창에 뭔가 타이핑을 할 때마다 실시간으로 데이터를 수정했음 -> 실용적이지 못함
- 매일 수천만 건의 질의가 입력될 텐데 그때마다 트라이 갱신하면 질의 서비스는 심각하게 느릴 것
- 일단 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이므로 잦은 갱신이 필요없다
### 데이터 분석 서비스 로그
데이터 분석 서비스 로그에는 검색창에 입력된 질의에 관한 원본 데이터가 보관됨
### 로그 취합 서버
- 데이터 분석 서비스로부터 나오는 로그는 보통 그 양이 엄청나고 데이터 형식도 제각각인 경우가 많아 잘 취합해야함
- 트위터 같은 실시간 앱의 경우 데이터 취합 주기를 짧게 가져가고, 거색어 자동완성 같은 경우 일주일에 한번 정도로 해도 충분할 것

### 취합된 데이터
질의문자, 날짜, 빈도의 컬럼으로 구성
### 트라이 데이터베이스
데이터베이스 선택지는 두가지가 있다
1. 문서 저장소 : 새 트라이를 매주 만들 것이므로 몽고디비 같은 곳에 주기적으로 직렬화하여 저장하면 좋다
2. 키-값 저장소 : 로직을 적용해 트라이를 해시 테이블 형태로 저장
  - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
  - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환
  - ex. be : [be:15, beer: 10], beer: [beer: 10]
## 질의 서비스
질의 서비스 최적화 방안
1. AJAX 요청
2. 브라우저 캐싱
3. 데이터 샘플링: N개의 검색 요청 가운데 1개만 로깅하도록 함

## 트라이 연산
### 검색어 삭제
문제가 되는 질의어는 자동완성 결과에서 제거해야 함
- 트라이 캐시 앞에 필터 계층을 두어 걸러냄
- 데이터베이스에서 해당 검색어 물리 삭제는 다음번 업데이트 사이클에 비동기적으로 진행하면 됨

## 저장소 규모 확장
- 영어만 사용하는 요구사항 기준
  - 질의 첫 글자를 기준으로 샤딩
  - 26개 보다 더 늘리고 싶다면 글자수를 추가해서 샤딩
  - 균등 배분이 어려움(x로 시작하는 글자와 c로 시작하는 글자의 검색 빈도는 완전 다를 것)
    - 검색어 대응 샤드 관리자를 두어 균등 배분시키자
   
## 4단계) 마무리
추가적으로 논의해볼 상황
### 다국어 지원
트라이에 유니코드 데이터 저장
### 국가별 인기검색어 순위 다르게 하려면
국가별로 다른 트라이 사용, 트라이를 CDN에 저장하면 응답속도도 높아질 것
### 실시간 급상승 검색어 반영 불가한 설계
- 순위모델링에 최근 검색어 가중치를 높인다
- 수동으로 트라이 업데이트 돌려야할 듯
