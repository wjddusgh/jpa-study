# 11.결제 시스템

## 결제 시스템이란?
### 금전적 가치의 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 시스템


## 문제 이해 및 설계 범위 확정
- 사람마다 결제 처리 시스템을 다르게 생각하기에 정확한 요구사항을 파악해야 함
- 아마존의 전자상거래 시스템 예시

### 기능 요구사항
- 대금 수신(pay-in) 흐름: 고객으로부터 대금 수령
- 대금 정산(pay-out) 흐름: 판매자에게 판매 대금 송금

### 비기능 요구사항
- 신뢰성 및 내결함성: 결제 실패는 신중히 처리
- 내외부 서비스간 조정 프로세스: 시스템간 결제정보 일치 여부 비동기적 확인

### 개략적 규모 추정
- 하루 100만건 -> 약 10 TPS
- 일반적인 DB로 충분히 커버 가능하므로 처리 대역폭 대신, 결제 트랜잭션의 정확한 처리에 초첨을 맞춘다

## 개략적 설계안 제시 및 동의 구하기

### 대금 수신 흐름
~~그림11.2~~
#### 결제 서비스
- 사용자로부터 결제 이벤트를 수락하고 결제 프로세스 조율
- 위험 확인 서비스는 복잡하기에 제3자 제공업체 이용

#### 결제 실행자
- 결제 서비스 공급자(PSP)를 통해 결제 주문 하나 실행
- 하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있음

#### 결제 서비스 공급자
- A 계정에서 B 계정으로 돈을 옮기는 역할 담당
- 예제의 경우 구매자의 신용카드 계좌에서 돈을 인출하는 역할

#### 카드 유형
- 복잡한 카드 업무 처리

#### 원장
- 결제 트랜잭션에 대한 금융 기록
- 결제 후 분석에서 매우 중요한 역할

#### 저장 정보
- 결제 이벤트
- 결제 주문
- 결제 성공 시 지갑을 갱신하여 판매자 잔고 저장
- 원장 정보

### 결제 서비스 API
#### POST /v1/payments
~~여기에 표 11.1, 표11.2~~
- `pay_order_id` 는 전역적으로 고유한 ID, 멱등 키로 사용
- `amount` 는 `double` 아닌  `string` 으로 저장, 직렬화/역직렬화 중에 의도치 않은 반올림 오류 생길 수 있기 때문에

#### GET /v1/payments/{:id}
- `payment_order_id` 가 가리키는 단일 결제 주문 상태 반환

### 결제 서비스 데이터 모델
- 결제 이벤트, 결제 주문의 두 테이블 필요
- 성능은 고려사항 X
- 안정성, DBA 채용시장의 성숙도, 모니터링 도구 등을 따져 ACID 지원하는 전통적인 RDBMS 선호

~~표11.3, 11.4~~
### 복식부기 원장 시스템
- 복식부기(double-entry): 모든 결제 거래를 두 별도 원장 계좌에 같은 금액으로 기록

### 외부 결제 페이지
- 신용카드 정보를 내부에 저장할 경우 국가의 복잡한 규정을 준수해야 함
- 이를 취급하지 않기 위해 기업들은 PSP 에서 제공하는 **외부 결제 페이지** 사용
- 웹사이트의 경우 widget 또는 iframe, 모바일의 경우 sdk에 포함해 제공

### 대금 정산 흐름
- 대금 수신 흐름과 유사
- 타사 정산 서비스를 사용하여 전자상거래 사이트 은행 계좌 -> 판매자 계좌로 이체
- 대금 정산도 복잡한 규제, 요구사항이 있어 외상매입금 지급 서비스 제공업체 이용

## 상세 설계
### PSP 연동
~~그림11.4~~
- 결제주문 용 비중복 난수 필드는 UUID 사용
- 민감한 결제정보는 우리 시스템으로는 절대 넘어오지 않음

### 조정
- 시스템 구성 요소가 비동기적으로 통신하는 경우 성공 보장이 안됨
- 조정: 관련 서비스간의 상태를 주기적으로 비교하여 일치하는지 확인하는 것
- PSP 또는 은행의 정산 파일을 받고, 원장 시스템과 비교하여 차이가 있는지 검사
- 이 때 원장, 지갑의 상태를 체크하여 내부 일관성도 확인 가능
- 발견한 불일치 문제는 유형에 따라 분류함
  - 어떤 유형 문제인지 알고, 해결 절차를 자동화할 수 있는 경우 : 자동화하여 처리
  - 어떤 유형 문제인지는 아는데, 해결 절차가 자동화 안되는 경우 : 작업 대기열에 넣고 수동으로 수정
  - 분류 못하는 유형의 문제 : 특별 작업 대기열에 넣고 조사
 
### 결제 지연 처리
- 결제 서비슨는 처리하는 데 시간이 올래 걸리는 요청도 처리할 수 있어야 함
#### PSP 의 처리 방법
- 결제가 대기(Pending) 상태임을 알리는 상태 정보를 클라이언트에 반환, 클라이언트는 이를 사용자에게 표시
- PSP 가 결제 서비스를 대신하여 대기중인 결제 진행상황 추적하고, 상태가 바뀌면 웹훅을 통해 결제 서비스에 알린다
- 일부 PSP 는 웹훅 대신, 결제 서비스가 주기적으로 폴링 하도록 함

### 내부 서비스 간 커뮤니케이션
#### 동기식 통신
- HTTP 같은 동기식 통신은 단점이 분명함
  - 성능 저하: SPOF
  - 장애 격리 곤란: PSP등의 서비스 장애 나면 클라이언트는 더이상 응답 받지 못함
  - 높은 결합도: 요청 발신자는 수신자를 알아야 함
  - 낮은 확장성
#### 비동기 통신
- 단일 수신자 : 공유 메시지큐로, 복수의 구독자가 있을 수 있지만 처리된 메시지는 큐에서 바로 제거됨
- 다중 수신자 : 카프카 같은 경우로, 하나의 요청이 여러 서비스에 쓰일 수 있어 결제 시스템에 적합

### 결제 실패 처리
#### 결제 상태 추적
- 결제 주기의 모든 단계에서 결제 상태를 정확하게 유지하는 것은 매우 중요
- 결제 상태를 데이터 추가만 가능한 데이터베이스 테이블에 보관

#### 재시도 큐
- 일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보냄
  - 재시도 횟수가 임계값 이내여야함
  - 임계값을 넘는다면 실패 메시지 큐에 보냄
  - 실패 메시지 큐: 문제가 있는 메시지를 디버깅 
- 잘못된 입력 같이 재시도가 불가능한 실패는 오류 내역을 데이터베이스에 저장

### 정확히 한 번 전달
- 최소 한번은 실행 과 최대 한번 실행을 충족하면 됨

#### 재시도
- 결제 실패 응답을 받을 경우 재시도
- 여러 재시도 메커니즘이 있지만, 너무 잦은 재시도 요청으로 리소스 낭비를 막기 위해 지수적 백오프를 주로 사용함
- 결제 실패 응답을 보낼 때 `Retry-After` 헤더를 같이 보내는 것도 좋은 방법
- 재시도만 있다면 이중 결제의 위험 존재

#### 멱등성
- 이중 결제 막기 가능
- UUID 를 멱등 키로 사용하여 멱등성 유지
- 동일한 멱등 키로 동시에 많은 요청이 오면 `429:Too Many Requests` 반환

### 일관성
#### 데이터 다중화
- 복제 지연으로 인한 불일치 문제 발생 가능
- 해결책
  - 주 데이터베이스에서만 읽기/쓰기 처리, 규모 확장성이 떨어지고 리소스 낭비가 큼(부 데이터베이스는 오직 안정성 보장용)
  - 합의 기반 분산 데이터베이스 사용
 
### 결제 보안
~~표11.6~~
