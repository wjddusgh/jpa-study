# 9. S3와 유사한 객체 저장소

## Amazon S3
- RESTFul 기반 인터페이스로 이용가능한 객체 저장소
```
gpt4o 요약
Amazon S3는 AWS의 확장 가능하고 안전하며 고가용성의 객체 스토리지 서비스로,
데이터를 인터넷에서 쉽게 저장하고 검색할 수 있습니다. 버킷과 객체로 구성되며,
높은 내구성, 가용성, 보안성을 제공하여 다양한 데이터 저장 및 관리 요구를 충족합니다.
```
## 저장소 시스템 101
### 저장소 종류
- 블록(Block) 저장소
- 파일(File) 저장소
- 객체(Object) 저장소

### 블록 저장소
- 원시 블록을 서버에 볼륨 형태로 제공
- 가장 유연하고, 융통성이 높은 저장소
- 물리적 연결(HDD, SSD), 네트워크 연결(FC, iSCSI) 모두 블록저장소

### 파일 저장소
- 블록 저장소 위에 구현됨
- 데이터는 계층적으로 구성되는 디렉터리 안에 보관됨
- 하나의 저장소를 여러 서버에 동시에 붙일 수 있다(파일 수준 네트워크 프로토콜 사용 시)

### 객체 저장소
- 데이터 영속성을 높이고 대규모 애플리케이션 지원하며 비용 낮추기 위해 의도적으로 성능을 희생
- cold 데이터 보관에 초점을 맞춤
- 모든 데이터를 수평적 구조 내에 객체로 보관
- 계층적 디렉터리 제공 X
- 데이터 접근은 RESTful API 사용
- 다른 저장소 유형에 비해 상대적으로 느림

### 객체 저장소 용어 정리

#### 버킷 (Bucket)
- Amazon S3에서 데이터를 저장하는 기본 단위.
- 고유한 이름을 가지며 전역적으로 유일, 데이터가 저장되는 물리적 위치(리전)를 정의.

#### 객체 (Object)
- S3에 저장되는 기본 데이터 단위.
- 데이터 자체와 메타데이터로 구성되며, 고유한 키로 식별.
- 메타데이터는 객체를 기술하는 이름-값 쌍의 집합

#### 버전 (Version)
- S3 버킷에서 객체의 변경 내역을 관리하는 방식.
- 버전 관리를 활성화하면 객체의 모든 버전을 저장하여 데이터 복구 및 변경 추적이 가능.

#### URI (Uniform Resource Identifier)
- S3의 객체를 식별하는 고유한 경로.
- `s3://bucket-name/key` 형식으로 나타내며, 객체에 접근하는 데 사용.
- key 는 Object Name

#### SLA (Service Level Agreement)
- 서비스 제공자가 보장하는 서비스 수준.
- Amazon S3 SLA: 99.99%의 가용성, 99.999999999%의 객체 내구성을 보장하며, 하나의 가용성 구역 전체가 소실되어도 데이터 복원 가능, 서비스 수준을 충족하지 못할 경우 보상 정책을 제공.

## 문제 이해 및 설계 범위 확정
### 기능 요구사항
- 버킷 생성
- 객체 업로드, 다운로드
- 객체 버전
- 버킷 내 객체 목록 출력 기능(aws s3 ls 와 유사해야함)
### 비기능 요구사항
- 매년 100PB 추가
- 식스나인(99.9999%) 수준 데이터 내구성
- 포나인(99.99%) 수준 서비스 가용성
- 저장소 효율성 : 높은 수준의 안정성, 성능 보증하되 저장소 비용은 최대한 낮추어야함

### 대략적인 규모 추정
- 디스크 용량 : 일반적인 분포를 따를 때 6.8억개 객체, 0.68TB 정도의 메타데이터 저장 공간(메타데이터는 1객체당 1KB 정도라 가정)
- IOPS : HDD, SATA 인터페이스 기준 100~150 IOPS (S3 Glacier 가 장기 아카이빙을 위한 스토리지로, 주로 HDD 사용한다고 함)

## 개략적 설계안 제시 및 동의 구하기
### 객체저장소의 흥미로운 속성
#### 객체 불변성
- 객체 저장소에 보관되는 객체들은 변경이 불가능함
- 객체 저장소와 다른 두 저장소 유형의 가장 큰 차이
- 삭제 후 새 버전 객체로 대체할 순 있어도, 점진적 변경은 불가
#### 키-값 저장소
- 키: URI, 값: 객체 데이터
#### 저장은 1회, 읽기는 여러 번
- 쓰기는 1회, 읽기는 여러번 발생
- 링크드인 조사 결과에 따르면, 객체 저장소 요청의 95%는 읽기 요청
#### 소형, 대형 객체 동시 지원
- 다양한 크기의 객체를 문제 없이 저장할 수 있다

### 설계 철학이 UNIX 파일 시스템과 유사
- 메타데이터 : 아이노드
- 데이터 저장소 : 하드디스크
- 차이점
  - 메타데이터에는 데이터저장소에 보관된 객체를 요청하는데 필요한 식별자(ID)가 보관됨
  - 아이노드에는 파일 블록 포인터 목록이 저장됨
### 개략적 설계안
 ![KakaoTalk_Photo_2024-05-20-13-46-41](https://github.com/wjddusgh/jpa-study/assets/69251780/2f1f3f05-9dbb-4773-8494-9846c4058b65)

#### 로드 밸런서
RESTful API 요청을 서버들에 분산
#### API 서비스
여러 서비스에 대한 호출을 조율하는 역할, 무상태 서비스이므로 수평적 규모 확장 가능
#### IAM 서비스
인증, 권한 부여, 접근 제어 처리
#### 데이터, 메타데이터 저장소
- 각각 실제 데이터, 메타데이터를 보관하는 저장소
- 실제 데이터 관련 연산은 객체 ID(UUID) 통해서 이루어짐
- 두 저장소는 논리적 구분일 뿐, 구현 방식은 여러가지 있을 수 있음

### 객체 업로드
1. HTTP PUT 요청으로 버킷 생성
2. IAM 호출하여 버킷 WRITE 권한 확인
3. 버킷 메타데이터 생성(메타데이터 저장소)
4. HTTP PUP 요청으로 script.txt 객체 생성
5. IAM 호출하여 객체 WRITE 권한 확인
6. 객체 업로드
7. 객체의 메타데이터 등록(object_name, object_id, bucket_id)

### 객체 다운로드
- 계층 구조는 없지만, 버킷이름, 객체이름 연결하면 논리적으로 흉내낼 수 있음(ex. /bucket_name/script.txt)
1. HTTP GET 요청으로 객체 요청
2. IAM 호출하여 버킷 READ 권한 확인(버킷 내 객체별로도 ACL 가질 수 있다함)
3. 권한 있으면 api 서비스가 해당 객체 uuid 를 메타데이터 저장소에서 가져옴
4. uuid 로 객체 저장소에서 데이터 가져옴
5. HTTP 응답으로 데이터 반환

## 상세 설계

### 데이터 저장소
![KakaoTalk_Photo_2024-05-20-15-01-34](https://github.com/wjddusgh/jpa-study/assets/69251780/eea0e5e1-3f03-4d39-9654-fa32268d5f0a)

#### 데이터 라우팅 서비스
- 데이터 노드 클러스터에 접근하기 위한 RESTful 또는 gRPC 서비스 제공
- 무상태 서비스
- 역할
  - 배치 서비스를 호출하여 데이터를 저장할 최적의 데이터 노드 판단
  - 데이터 노드에서 데이터를 읽어 API 서비스에 반환
  - 데이터 노드에 데이터 기록
#### 배치 서비스
- 어느 데이터 노드에 데이터를 저장할지 결정하는 역할
- 내부적으로 가상 클러스터 지도 유지, 클러스터의 물리적 형상 정보가 보관됨
- 가상 클러스터 지도 이용하여 데이터 사본이 물리적으로 다른 위치에 놓이도록 함(높은 데이터 내구성 유지하는 핵심 요소)
- 모든 데이터 노드와 지속적으로 박동 메시지를 주고받으며 상태를 모니터링(15초 동안 응답 안한 노드는 지도에 죽은(down) 노드로 표시)
- 아주 중요한 서비스이므로 5~7 노드를 갖는 배치 서비스 클러스터를 합의 프로토콜 사용해 구축할 것 권장
- 합의 프로토콜
  - 분산 시스템에서 여러 노드가 동일한 결정을 내릴 수 있도록 하는 메커니즘
  - 분산 환경에서 데이터의 일관성과 무결성을 보장하는 데 필수적
  - 일부 노드에 장애가 생겨도 건강한 노드 수가 클러스터 크기의 절반 이상이면 서비스 지속할 수 있도록 보장
#### 데이터 노드
- 실제 객체 데이터가 보관되는 곳
- 여러 노드에 데이터를 복제함으로써 다중화그룹 을 통해 데이터 안정성, 내구성 보증
- 배치 서비스에 주기적으로 박동 메시지 보내는 서비스 데몬 존재
- 박동 메시지
  - 해당 데이터 노드에 부착된 디스크 드라이브의 수
  - 각 드라이브에 저장된 데이터의 양
- 배치 서비스가 못보던 데이터노드에서 박동 메시지 받으면, 해당 노드에 ID 부여 후 가상 클러스터 지도에 추가, 아래 정보 반환
  - 해당 데이터노드에 부여한 고유 식별자
  - 가상 클러스터 지도
  - 데이터 사본을 보관할 위치
#### 데이터 저장 흐름
1. API 서비스가 객체 데이터를 데이터 저장소로 포워딩
2. 데이터 라우팅 서비스가 해당 객체에 UUID 할당, 배치 서비스에 해당 객체 보관할 주 데이터 노드 반환 요청
3. 데이터 라우팅 서비스가 저장할 데이터를 UUID 와 함께 주 데이터 노드에 직접 전송
4. 주 데이터 노드는 데이터를 자기 노드에 지역적으로 저장하는 한편, 두 개의 부 데이터 노드에 다중화함. 다중화까지 성공하면 데이터 라우팅 서비스에 응답 보냄
5. 객체의 UUID, 즉 객체 ID 를 API 서비스에 반환

- 배치 서비스에서 데이터 노드 조회 연산 구현에는 보통 안정 해시를 사용함
- 데이터 노드 다중화의 경우 응답을 보내는 경우를 나눌 수 있다
  - n 개의 부 데이터 노드 저장 완료 응답을 0~n 개 받을 경우 데이터 저장 완료 응답 보내기
  - n 개 받을 경우 : 데이터 일관성 측면에서는 최선이지만, 응답 지연은 가장 높다
  - 나머지 : 갯수에 따라 데이터 일관성<> 응답 지연간 trade off, 결과적 일관성 형태

### 데이터는 어떻게 저장되는가
