# 11. 클라이언트 식별과 쿠키
서버가 통신하는 대상을 식별하는데 사용하는 기술
## 11.1 개별 접촉
- HTTP 는 익명, Stateless, 요청-응답 으로 통신
- 서버가 방문자가 보낸 연속적인 요청 추적하기 위해 약간의 정보 이용 가능
- 개인화 서비스에도 필요함

## 11.2 HTTP 헤더
### From
- 사용자의 이메일 주소 포함
- 이론상 이걸로 식별 가능하지만, 악의 있으면 곤란해짐
### User-Agent
- 사용자가 쓰고 있는 브라우저의 이름, 버전, OS 정보
- 특정 브라우저에 맞춰 최적화 가능
- 사용자 식별엔 크게 도움 안됨
### Referer
- 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL 가리킴
- 사용자 취향 파악에 굳
- 이 세개로는 사용자 식별엔 아쉬움

## 11.3 클라이언트 IP 주소
- ip 주소는 식별에 좋음
- http 헤더에는 없지만, http 요청을 보내는 반대쪽 tcp 커넥션의 ip 주소를 알아낼 수 있음
- 약점
  - 사용자가 아닌 사용 컴퓨터를 가리킴, 여러 사용자가 같은 컴퓨터 사용시 곤란
  - isp 가 동적으로 ip주소 할당하므로, 로그인 시간에 따라 주소가 바뀜
  - 네트워크 주소 변환 방화벽
  - 웹서버가 클라이언트 대신 프록시의 ip주소 보기도 한다고 함
- 이러한 약점들 때문에 잘 사용 안함
- ip 주소는 인트라넷에서만 적절함

 ## 11.4 사용자 로그인
 - 웹 서버가 사용자 이름, 비밀번호로 인증핡것을 요구
 - http 는 `WWW-Authenticate`, `Authoriztion` 헤더 사용해 사용자 이름 전달하는 자체적 체계 가짐
 - 로그인 시 계속 보내므로 항상 로그인 정보 확인 가능
 - 로그인 전 접근 차단 -> 401 Login Required

## 11.5 뚱뚱한 url
- 뚱뚱한 url : 사용자의 상태 정보를 포함하고 있는 url
- 흐름
  - 클라이언트의 첫 방문 시 유일한 id 생성
  - url 에 유일한 id추가 시켜 클라이언트를 리다이렉트 시킴
  - 이후 서버가 뚱뚱한 url 요청 받으면, 모든 하이퍼링크를 뚱뚱한 url 로 변경
- 문제
  - 못생긴 url : 더럽게 긴게 문제인듯
  - 공유하지 못하는 url : 상태정보 포함한 url 이라 공유하면 곤란
  - 캐시 사용 불가 : url 이 매번 달라지기 때문에 캐시 사용 불가
  - 서버 부하 가중 : 뚱뚱한 url 처리는 서버가 함
  - 이탈 : 사용자가 도중 이탈시 뚱뚱한 url 첨부터 다시 만들어야함
  - 세션 간 지속성의 부재 : 뚱뚱한 url 북마크 하는거 아닌 이상, 로그아웃 시 다 날아감

## 11.6 쿠키
- 사용자 식별, 세션 유지하는 방식중 현재까지 가장 널리 사용되는 방식
- 넷스케이프가 최초 개발, 지금은 모든 브라우저가 지원
- 쿠키는 캐시와 충돌 가능성 있음 -> 대부분 캐시, 브라우저는 쿠키 캐싱 안함

### 쿠키의 타입
- 세션 쿠키 : 사이트 탐색시, 관련한 설정과 선호사항 저장하는 임시 쿠키
- 지속 쿠키 : 디스크에 저장되어, 나중에도 남아있는 쿠키. 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름 저장
- 둘은 파기 시점 차이임. Discard 파라미터 있거나 혹은, Expires 나 Max-Age 파라미터 없으면 세션 쿠키임
### 쿠키는 어떻게 동작하는가
- 쿠키는 이름-값 형태 리스트를 가지고, HTTP 의 Set-Cookie 혹은 Set-Cookie2 응답 헤더에 기술되어 사용자에게 전달됨
- 브라우저는 서버에서 온 Set-Cookie 헤더에 있는 쿠키 컨텐츠를 브라우저 쿠키 데이터베이스에 저장함
### 쿠키 상자: 클라이언트 측 상태
- 쿠키 사용 : 브라우저가 서버 관련 정보 저장 -> 사용자가 서버에 접근할 때 이 쿠키정보 같이 전송
- 클라이언트측 상태 : 브라우저는 쿠키를 저장할 책임이 있다! 는 의미
