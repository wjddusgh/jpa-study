# 4. 커넥션 관리
## 4.1 TCP 커넥션
- 전세계 모든 http 통신은 tcp/ip를 통해 이루어진다
- 메시지들은 손실, 손상 혹은 순서가 바뀌는 일이 없다(네트워크가 터지면 문제발생가능)

## TCP는?
- 충돌 없이 순서에 맞게 http 데이터 전달
- ip 패킷 단위
  - ip 패킷 헤더
  - tcp 세그먼트 헤더
  - tcp 데이터 조각
<img width="546" alt="asdf" src="https://github.com/wjddusgh/jpa-study/assets/69251780/c728a883-8f9b-48ab-b5e9-d80bbe899164">

- https 는 http 에서 전송 계층과 애플리케이션 계층 사이에 보안 계층(tls or ssl) 추가한 것
- 메시지 데이터 스트림은 세그먼트 단위로 잘게 나누고, ip 패킷에 넣어 보낸다
- 이 모든 과정은 http 는 모름
- tcp 커넥션은 `<발신지 ip, 발신지 port, 수신지 ip, 수신지 port>` 값으로 식별함(unique함)
- 컴퓨터는 항상 여러 tcp 커넥션을 가짐
- **소켓 api** 가 tcp 커넥션 관련 기능 제공

## 4.2 TCP의 성능에 대한 고려
- 트랜잭션 지연 에서 대부분은 연결과정이 차지한다
- 근데 요즘은 네트워크 인프라가 좋아 밀리초단위이다
- handshake 지연
  - 속도야 빠르다만, http 요청 메시지 자체가 작은 경우 syn, ack 보다 작으면 손해보는기분
- 확인응답 지연
  - ack 를 다른 패킷에 piggyback 하는 알고리즘이 있다
  - 소켓 프로그래밍엔 좋다는데, 연결을 자주 끊는 http 에선 오히려 손해일수가 있다
- tcp 느린 시작
  - tcp 는 처음 연결시엔 최대 속도 제한 두면서 천천히 높여나간다고 한다
  - 이런식으로 혼잡제어를 한다
  - http 는 손해가 막심하므로 이미 존재하는 커넥션을 재사용하는 `지속 커넥션` 기능이 있다고 한다
- 네이글 알고리즘
  - 세그먼트가 최대 크기(랜선에선 1500, 인터넷상에선 수백 바이트 정도) 가 아니면 안보내고, 다른 모든 패킷이 확인응답 받은경우에나 최대 아니어도 보내준다
  - 그래서 크기 작은애는 괜히 기다린다
  - 확인응답 지연 때문에 괜히 더 느려진다
  - http 스택에 `TCP_NODELAY` 설정하면 이 알고리즘 비활성화된다
- TIME_WAIT의 누적과 포트 고갈
  - 세그먼트 최대 생명주기 두배 정도로 새로운 tcp 커넥션(4가지 요소가 같은) 안생기게 제한하는데
  - 이거때매 더이상 새로운 커넥션 못만들게 될수도 있다
  - 주로 부하테스트때 발생해서 오해하게 만듦

## 4.3 HTTP 커넥션 관리
- http 는 중개 서버(프락시, 캐시 등)를 허락함
  - 그래서 원하는곳 이외까지 전달 안되게끔 close 등의 특정 명시가 가능
  - 그러한 커넥션 헤더는 설정 사용되면 다른 서버에 전달 안되게 삭제(?)
- 순차적인 트랜잭션 처리 의한 지연
  - 여러 트랜잭션이 필요한데 각각 다른 커넥션 만들면 느림(slow start때매)
  - 심지어 각각 따로 순서대로 가져오면 화면이 비어보임(이미지,영상 등 가져오는 트랜잭션 있는경우)
  - 해결법은?
    - 병렬 커넥션: 여러 tcp 커넥션 통한 동시 http 요청
    - 지속 커넥션: 커넥션 계속 유지
    - 파이프라인 커넥션: 공유 tcp 커넥션을 통한 병렬 http 요청
    - 다중 커넥션: 요청, 응답에 대한 중재
## 4.4 병렬 커넥션
- 병렬이라 각각 순서대로 보다 빠르다
- 근데 네트워크 대역폭이 좁거나 메모리가 작으면 버거워해서 항상 더 빠르진 않다
- 한번에 많은 커넥션 쓰니까 서버가 커넥션 갯수 딸릴수도 있다
- 근데 그래도 한번에 다 가져오는게 사람 심리상 빨라보인댄다
## 4.5 지속 커넥션
- 사이트 지역성: 한 사이트에 자주 요청할 일이 많다
- HTTP/1.1 사용 시 tcp 커넥션을 유지하여 또 요청할 수 있게 해줌
- slow start 지연도 방지됨
- 요즘엔 적은 수의 병렬 커넥션을 지속커넥션과 결합함
- HTTP/1.0+ 에는 keep-alive 커넥션도 있음
  - Connetcion 헤더에 Keep-Alive 넣으면 유지, 없으면 커넥션 끊음
  - 하지만 요청일 뿐, 무시하고 끊을 수도 있음
  - 프락시, 게이트웨이는 규칙 철저히 지켜야 함, 메시지 전달 혹은 캐시에 넣기 전 모든 헤더 제거해야함
  - Content-Length 를 잘 지켜야함
- 멍청한 proxy
  - HTTP/1.0 을 따르는 기기에는 커넥션 헤더 필드가 무시되어야함
  - 그런데 멍청한 proxy 는 keep-alive 를 실행도 안하고 서버에 전달할수도 있음
  - 괜히 proxy는 다 끊는데 클라, 서버만 뻘짓 가능
  - 이를 해결하기 위해 Proxy-Connection 헤더 만듦, 서버는 이걸 무시함
- HTTP/1.1 에서는 지속커넥션이 디폴트
- Connection: close 헤더 보내야 커넥션 끊음

## 4.6 파이프라인 커넥션
- 요청의 응답이 안와도 다음 요청 보냄
- 조건
  - 지속 커넥션인지 확인하기 전엔 파이프라인 불가
  - 응답은 요청 순서와 같게 와야함
  - 예상치 못한 커넥션 끊김에도 재시도 할 수 있어야함
  - 멱등성 있는 요청만 파이프라인 태워라

## 4.7 커넥션 끊기에 대한 미스터리
- 언제 어디서나 커넥션은 끊을수가 있어서 언제 문제생길지 모른다
- content-length 를 포함 안하는 응답 도 있어서 문제 생길 수 있다
- 커넥션이 끊기면 재시도 되어야 하므로 멱등성이 없는 요청은 위험할 수 있다
- 우아하게 커넥션 끊기
  - 커넥션은 입출력 두개인데, close() 시 전체끊기, shutdown() 시 절반끊기 가능하다
  - 보통은 출력 끊기 하면 이상한 에러 방지 좋음
  - 입력 끊기 상태로 그쪽으로 요청오면 운영체제는 심각한 에러로 취급하여 아직 안읽고 쌓인 데이터 다날린다
  - 그니까 입력 끊기는 상대방의 출력이 끊겼는지 확인하고 하는게 우아하다
