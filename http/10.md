# 10. HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경
- HTTP/1.1의 메시지 포멧은 구현의 단순성, 접근성을 두고 최적화됨
- 그래서 성능이 어느정도 희생됨
  - 요청당 커넥션, 응답도 하나만 받음 -> 단순하지만, 심각한 회전 지연 만남
  - 병렬 커넥션, 파이프라인 커넥션 도입됐지만 근본적 해결책은 아님
- SPDY : 구글이 개발, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연 줄임, 서버가 능동적 리소스 푸시 기능
  - 이를 기반으로 HTTP/2.0 만들기 시작

## 10.2 개요
- HTTP/2.0 요청, 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담긴다. 헤더는 압축되어 담긴다
- 프레임에 담긴 요청, 응답은 스트림을 통해 보내진다
- 하나에 커넥션엔 여러 스트림이 만들어 질 수 있으므로, 여러 요청, 응답을 동시에 처리 가능하다
- 이들 스트림에 대한 흐름제어, 우선순위 부여 기능 제공
- 2.0부터는 기존 요청-응답과는 살짝 다른 서버 푸시를 도입함
  - 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 요청 없이도 능동적으로 푸시 가능하다
- 기존 버전과의 호환을 위해 요청, 응답 메시지 의미는 1.1과 동일함

## 10.3 HTTP/1.1과의 차이점

### 프레임
- 모든 메시지는 프레임에 담겨 전송된다
- 필드
  - R : 예약된 2비트 ㅍ리드, 값 의미 없고 반드시 0이어야함. 받는쪽에선 이 값 무시
  - 길이 : 페이로드의 길이는 나타내느 14비트 unsigned integer. 헤더는 제외
  - 종류 : 프레임 종류
  - 플래그 : 8비트 플래그
  - R : 예약된 1비트 필드. 반드시 0
  - 스트림 식별자 : 31비트 스트림 식별자, 0은 커넥션 전체와 연관된 프레임임을 의미함
- 프레임 정의는 총 10가지, 페이로드 형식과 내용은 프레임 종류에 따라 다름

### 스트림, 멀티플렉싱
- 1.1에서 발생하던 회전 지연을 2.0에선 한 커넥션에 여러 스트림 동시에 열리는걸로 해결
- 모든 스트림은 31비트의 unsigned int 로 고유한 식별자 가짐
- 스트림이 클라이언트에 의해 초기화 되었다면 식별자는 반드시 홀수, 서버라면 반드시 짝수
- 생성시간에 따라 식별자 값이 커져야 한다
- 규칙 어기면 `PROTOCOL_ERROR` 커넥션 에러로 응답
- 스트림은 상호 협상없이 일방적으로 만든다 -> TCP 패킷 주고받으며 연결하는 시간낭비가 없음 (왜이러냐면 이미 커넥션을 만들때 3-way handshake 했으니까)
- 한번 사용한 스트림 식별자는 다시 사용할 수 없다
- 커넥션 오래 사용해서 스트림 식별자가 고갈되면, 그냥 다시 커넥션 맺으면 된다
- 동시에 여러 스트림 사용 시 스트림 블록될 우려가 있다는 주장이 있다 -> WINDOW_UPDATE 프레임 이용한 흐름 제어로 막아준다

### 헤더 압축
- 요새는 헤더가 크니까 2.0부턴 헤더도 압축
### 서버 푸시
- 서버가 요청없이 클라이언트에 푸시
- PUSH_PROMISE 프레임으로 미리 클라이언트에 알려주긴 함
- 웹페이지 로딩 시 서버가 필요한거 예측해서 미리 보내면 성능 향상
- 리소스 낭비의 가능성이 높아짐

## 10.4 알려진 보안 이슈
### 중개자 캡슐화 공격
- 2.0 메시지가 프록시로 인해 1.1 메시지로 변환할 때 메시지 의미 변질될 가능성 존재
- 이유 : 2.0부터 헤더 필드의 이름과 값을 바이너리로 인코딩하므로, 헤더 필드에 어떤 문자열이든 사용할 수 있어서

### 긴 커넥션 유지로 인한 개인정보 누출 우려
- 회전 지연 줄이기 위한 긴 커넥션 유지
- stateless 의 반대되니까 개인정보 누출 가능성 커지나봄
