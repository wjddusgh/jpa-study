# 5. 웹 서버

## 5.1 다채로운 웹 서버
- 아주 다양하지만, 모두 리소스에 대한 http 요청 받아서 클라이언트에게 콘텐츠를 돌려준다
- 다목적 소프트웨어 웹서버
  - 표준 컴퓨터 시스템에서 동작
  - 아파치, 직소, nginx 등의 오픈소스 혹은 상용 소프트웨어 사용 가능   
- 임베디드 웹서버
  - 일반 기기를 간편하게 관리할수 있게 해주는 용도
## 5.3 진짜 웹 서버가 하는 일
1. 커넥션 맺기 : 클라이언트 접속 받기(원치 않는 클라는 닫는다)
2. 요청 받기 : http 요청 메시지를 네트워크로부터 읽음
3. 요청 처리 : 메시지를 통해 행동을 취함
4. 리소스 접근 : 메시지 행동에 필요한 리소스를 찾는다
5. 응답 만듦 : 올바른 헤더를 포함한 http 응답 메시지 생성
6. 응답 보냄 : 클라이언트에게 응답 보냄
7. 트랜잭션 로그로 남김 : 로그파일에 트랜잭션 완료 기록 남긴다

## 5.4 단계 1: 클라이언트 커넥션 수락
- 커넥션이 맺어지면 서버는 커넥션 목록에 추가하고 데이터 지켜볼 준비를 한다
- 대부분 웹서버는 역방향 dns 사용해서 클라이언트의 ip 주소를 호스트명으로 변환할수 있다
- 근데 이는 느리다
- ident 는 웹서버 로깅에 유용하지만, 대부분의 클라이언트는 실행하지 않기에 사용이 어렵다

## 5.5 단계2 : 요청 메시지 수신
- 요청줄 파싱 : 스페이스 단위로 분리되어 있고, CRLF 줄바꿈 문자열로 끝난다
- 메시지 헤더 : 여러 메시지 헤더들을 읽고, 각각은 CRLF로 끝난다
- 요청 본문 : 있을수도, 없을수도 있다. content-length 헤더로 정의된다
### 메시지의 내부 표현
- 몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장한다
  - @RequestParam 같은거(?)
### 커넥션 입력/출력 처리 아키텍처
- 고성능 웹 서버는 수천 개의 커넥션 동시 지원
- 요청 처리 방식
  - 단일 스레드 웹 서버 : 한번에 하나씩 요청 처리, 도중에 다른 커넥션은 무시됨
  - 멀티프로세스, 멀티스레드 웹 서버 : 여러 요청 동시 처리, 과한 메모리, 리소스는 곤란하므로 제한 있음(스레드풀 등)
  - 다중 I/O 서버 : 하나의 스레드나 프로세스가 여러 I/O 커넥션을 처리, I/O 에 따른 서버의 block이 매우 적음
  - 다중 멀티스레드 웹 서버 : 멀티스레딩 + 다중화

## 5.7 단계 4: 리소스의 매핑과 접근
- docroot: 요청에 대한 기본 디렉토리
- 가상호스팅된 docroot: 서버네임따라 각각의 docroot 가지게 함
- 사용자 홈 디렉토리 : `/~` 다음에 사용자이름을 넣어 같은 웹 서버에서 각각의 문서 루트를 가짐
### 디렉터리 url 대한 요청
- 행동
  - 에러 반환
  - 디렉토리 대신 특별한 색인 파일 반환 
  - 디렉토리 탐색한 내용을 담은 html 반환(보통 index.html 찾아 반환한다고 함)
### 서버사이드 인클루드(SSI)
- 정적 웹페이지에 태그에서 간단한 지시어로 동적인 내용 추가
- 이거는 너무 간단해서 대규모 애플리케이션에 안어울림

## 5.8 단계 5: 응답 만들기
