# 7. 캐시
## 7.1 불필요한 데이터 전송
- 캐시는 불필요한 같은 데이터 전송의 반복을통한 트래픽 증가를 막아줌
## 7.2 대역폭 병목
- 많은 네트워크가 원격 서버보단 로컬 클라이언트 쪽에 넓은 대역폭 제공
  - 그러니 서버 까지 가기전에 캐시가 있으면 큰 성능 개선
## 7.3 갑작스런 요청 쇄도(Flash Crowds)
- 갑작스러운 요청 쇄도에 캐시가 용이하다
## 7.4 거리로 인한 지연
- 물리적으로 멀면 느려지는것도 캐시가 용이하다
## 7.5 적중과 부적중
- 신선도 검사(HTTP 재검사) : 보유중인 캐시가 여전히 최신인지 검사하는것
  - 데이터 전체를 가져오지 않고도 최신 여부 확인 가능
  - 재검사 적중 : 304 반환
  - 재검사 부적중 : 최신의 데이터와 200 반환
  - 객체 삭제 : 객체가 삭제됐으면 404 반환하며 캐시 삭제
### 적중률
- 매우 다르겠지만 웹캐시는 40%면 괜찮은 편이라고 함
### 바이트 적중률
- 캐시의 데이터 크기에 따른 바이트 비중까지 합한 적중률
- 캐시로 돈받는 회사는 이거 따지는듯
### 캐시 히트 미스 구별
- HTTP 는 구별여부 제공 안해줌
- 특정 캐시(Nginx 등) 는 Via 헤더에 캐시관련 추가정보 넣어줌
- Date 헤더 열어서 응답 생성일이 요청 보다 예전이면 캐시인거 알 수 있음
## 7.6 캐시 토폴로지
### 개인 전용 캐시
- 웹 브라우저가 갖고있을 정도로 많은 공간 필요로 하지 않음
### 공용 프록시 캐시
- 트래픽 줄이는게 목표
- 이전 챕터에서 나왔듯이 여러 프록시 캐시 계층도 가능
- 캐시망 에서 할 수 있는 일
  - URL 에 근거하여 부모캐시와 서버중 하나를 동적으로 선택
  - URL 에 근거하여 특정 부모 캐시를 동적으로 선택
  - 부모캐시에게 가기전 캐시된 사본을 로컬에서 찾아봄
  - 다른 캐시들이 그들의 캐시된 컨텐츠에 부분적 접근을 허용하되, 인터넷 트랜짓(트래픽이 다른 네트워크로 가는것)은 금지시킴
- 형제 캐시 : 캐시들이 서롤를 연결해 찾아볼 수 있게 하는것
  - HTTP 는 지원 안함
  - ICP(인터넷 캐시 프로토콜), HTCP(하이퍼텍스트 캐시 프로토콜) 등으로 HTTP 확장해서 사용
## 7.7 캐시 처리 단계   
### 1. 요청 받기
- 네트워크 커넥션 활동 감지하고, 데이터를 읽어들인다
- 동시에 여러 데이터 읽을땐, 읽으면서 트랜잭션 처리 시작(데이터 다 오기 전부터)
### 2. 파싱
- 요청 메시지를 여러 부분으로 파싱하여 헤더부분을 조작하기 쉬운 자료구조에 담는다(해시나 맵에 담는듯)
### 3. 검색
- URL 통해 사본 여부 검사
- 캐시된 객체는 메타데이터(언제 생겼는지, 얼마나 사용됐는지 여부 등) 가짐
### 4. 신선도 검사
- 일정 조건 하에 캐시는 신선하다
- 안신선해졌을땐 요청이 왔을 때 재검사한다
### 5. 응답 생성
- 캐시된 서버 응답 헤더를 토대로 응답 헤더 작성
- 클라이언트의 요구 상황에 맞춰서 작성(응답의 HTTP 버전이 다른경우도)
- 캐시의 정보를 Via 헤더에 포함
- Date 헤더는 절대로 수정 금지
### 6. 전송
- 로컬 저장장치 -> 네트워크 버퍼로 바로 보내는 방법이 있나봄(제로 카피?)
### 7. 로깅
## 7.8 사본을 신선하게 유지하기
### 문서 만료
- HTTP 는 Cache-Control, Expires 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙이게 함
  - Expires : 만료 날짜가 적혀있음
  - Cache-Control
    - max-age : 초단위, 최대 캐시 수명
    - no-cache: 캐시를 해도, 서버에 확인해야함
    - no-store: 캐시 금지
    - public: 공용 캐시 가능
    - private: 오직 사적 단일 캐시만 가능
    - must-revalidate: 캐시 만료시 검사 꼭 해라
    - proxy-revalidate: 공유 캐시 만료시 검사 꼭 해라
    - s-maxage: 초단위, 공유 캐시 최대 수명
### 유효기간과 나이 
- 대부분 캐시 시스템은 Cache-Control 헤더 존재하면 Expires 무시한다고 함
  - Expires 는 HTTP/1.0, Cache-Control 은 HTTP/1.1 사양
### 서버 재검사
- 재검사 시 컨텐츠 변경 이라면 아예 새로운 사본을 가져옴
- 재검사 시 컨텐츠 그대로 라면 새로운 헤더만 가져와 캐시안의 헤더들을 갱신
### 조건부 메서드와의 재검사
- HTTP 는 캐시가 서버에게 `조건부 GET` 요청을 보낼수 있도록 해줌
  - 조건부 GET 은 기존 GET 에 조건부 헤더를 추가한 것
  - If-Modified-Since(IMS): <date> : 수정된 경우만 GET 처리, 아니면 304 반환(본문 제외)
  - If-None-Match: <tags> : 서버의 문서 태그와 캐시의 태그가 다를때만 요청 처리
### 약한 검사기, 강한 검사기
- HTTP/1.1 에서 컨텐츠가 조금 변경됐더라도 그정도는 같은 것! 이라고 처리해주는 약한 검사기 지원(태그 앞 `W/` 로 약한검사기 구분)
### 언제 엔티티태그, 언제 Last-Modified?
- 엔티티 태그 는 정확하지만 계산비용이 크다
- Last-Modified 는 간결하지만 추적(?) 이 어렵다고 함
- 병행해서 쓰자
## 7.9 캐시 제어
### 휴리스틱 만료
- 헤더에 아무런 캐시 만료 정보가 없으면 알고리즘으로 추측함
- LM 인자 알고리즘
  - 캐시와 서버의 대화시간, 최근 변경 일시로 계산함
  - 보통은 이 계산 시간의 상한을 설정(1일~7일)
- 저런 정보마저 없다면 그냥 신선도 수명 설정
### 클라이언트 신선도 제약
- Cache-Control 이용
  - max-stale : 캐시는 신선하지 않은 문서라도 자유롭게 제공 가능, 초 단위 변수를 제공해 만료시간으로부터 변수만큼 지나지 않은 캐시들 제공
  - min-stale : 클라이언트는 지금부터 적어도 변수 초까지만 신선한 캐시 받는다. 아주 엄격해짐
  - only-if-cached : 클라이언트는 오직 캐시에 들어있는 사본만 원한다
### 주의할 점
- 서버가 유효기간을 아득한 미래로 잡는다면 캐시는 영원히 갱신되지 않는다
- 아예 유효기간을 사용 안하는 경우도 많다

## 7.10 캐시 제어 설정
