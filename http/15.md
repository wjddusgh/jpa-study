# 15. 엔터티와 인코딩
## 15.1 메시지는 컨테이너, 엔티티는 화물
- 엔티티 헤더 : 18자 짜리 플레인 텍스트 문서, CRLF 로 헤더와 필드 구분
- HTTP/1.1 이 정의한 엔티티 헤더 필드
  - Content-Type
  - Content-Length
  - Content-Language: 전달된 객체에 대응되는 자연어
  - Content-Encoding
  - Content-Location
  - Content-Range : 이 엔티티가 부분 엔티티라면, 이 엔티티가 전체에서 어느 부분에 해당하는지
  - Content-MD5 엔티티 본문의 컨텐츠에 대한 체크섬
  - Last-Modified
  - Expires
  - Allow : 허용되는 메서드
  - ETag : 이 인스턴스에 대한 고유한 검사기, 엄밀히 말해 이건 엔티티 헤더로 정의되어 있지는 않지만, 엔티티 관련 많은 동작을 위해 중요한 헤더
  - Cache-Control : 캐싱때 배운, 캐시 관련 지시 헤더
### 엔티티 본문
- 가공되지 않은 데이터만을 담고있다
- 다른 정보들은 모두 헤더에 담김
- raw data를 엔티티 헤더를 보고 어떻게 해석할 지 아는것
- 헤더 필드 이후의 CRLF 이후 엔티티 본문 시작
### Content-Length: 엔티티의 길이
- 엔티티 본문의 크기를 바이트 단위로 나타냄
- 압축된 파일이라면 압축 후의 크기를 나타냄
- 메시지 잘림 문제 인지를 Content-Length 보고 파악함
- 캐시는 잘린 메시지를 캐싱하지 않기 위해, Content-Length 헤더 갖고있지 않는 http 본문은 보통 캐싱 안함
### 잘못된 Content-Length
- 이게 잘못된 값이면 매우 큰 피해 유발 가능
- 공식적으로 이게 잘못되어 있다면, 사용자에게 알려주게 되어있음
### 지속 커넥션
- Content-Length 는 지속 커넥션을 위해 필수(청크 인코딩 떄는 또 필요없다고함)
### 컨텐츠 인코딩
- 컨텐츠가 인코딩되어 있는 경우 인코딩 후의 본문 길이를 바이트 단위로 정의함
- 근데 1.1 명세에 없는 거라 문제 생길 때도 있음
### 엔티티 본문 길이 판별을 위한 규칙
- 본문 길이 판별을 위한 수칙으로, 나열된 순서대로 적용
1. 본문을 갖는것이 허용안된 http 메시지에는 Content-Length 헤더가 무시됨(ex. HEAD)
2. Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 `0바이트 청크` 패턴으로 끝나야 함.
3. Conteng-Length 헤더 갖는다면, Trnsfer-Encoding 존재하지 않는 이상 이 값은 본문의 길이를 담음.
4. `multipart/byteranges` 미디어타입을 사용하고 Content-Length 없다면, 멀티파트 메시지 각자가 스스로의 크기를 정의할 것
5. 위의 어떤 규칙도 해당하지 않는다면, 엔티티는 커넥션이 닫힐 때 끝남. 서버만이 커넥션 종료 가능함
6. HTTP/1.0과의 호환을 위해 엔티티 보눈을 갖고있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고있어야 함(3번에 왜안걸려)

## 15.4 미디어 타입과 차셋(Charset)
- Content-Type 헤더는 엔티티 본문의 MIME(전달되는 데이터 매체의 기저 형식) 기술함
- 이 헤더의 값은 IANA 에 등록된 표준화된 MIME타입
- MIME 는 `주 미디어타입/구체적인 부 타입` 으로 구성됨(ex. text/html, image/jpeg, multipart/byteranges 등)
### 멀티파트 미디어 타입
- 서로 붙어있는 여러개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐
- 각 구성요소가 자족적으로 자신에 대해 서술하는 헤더를 포함함
- 문자열 하나로 서로의 경계가 식별됨
- 일반적으로 폼을 채워서 제출할 때, 문서의 일부분을 실어나르는 범위 응답을 할때 사용(난 csv 파일 다운로드때 사용했는데 머지)
## 15.5 콘텐츠 인코딩
- 떄떄로 느린 클라이언트에게 큰 html 전송 전에 미리 인코딩 하기도 함
- 혹은 제3자가 못보게 컨텐츠를 암호화하는 경우도 있음
- 이러한 종류의 인코딩은 발송하는 쪽에서 컨텐츠에 적용함
- 컨텐츠 인코딩 유형 (전부 무손실 압축 알고리즘)
  - gzip : GNU zip 인코딩 적용됨
  - compress : 유닉스 파일 압축 프로그램
  - deflate : zlib 포맷으로 압축됨
  - identity : 어떤 인코딩도 수행되지 않음, Content-Encoding 헤더가 없다면 이 값인 것으로 간주됨   
## 15.6 전송 인코딩과 청크 인코딩
- 컨텐츠 인코딩은 컨텐츠 포맷과 연관되어 있어야함(gzip 은 텍스트엔 좋지만 이미지엔 안좋은 등의 경우 때문에)
- 컨텐츠 인코딩은 메시지의 엔티티부분만 인코딩하지만, 전송 인코딩은 전체 메시지에 적용된다
- 하지만 전송 인코딩은 보안, 알수없는 크기 문제때문에 흔하지 않다
- 컨텐츠 인코딩과 전송 인코딩은 동시에 사용 가능
### Transfer-Encoding 헤더
- Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다
- TE : 어떤 확장된 전송 인코딩을 사용할수 있는지 알려준다
- 최신 HTTP 명세에는 전송인코딩중 청크 인코딩만을 정의함

### 청크 인코딩
- 메시지를 일정 크기의 청크 여럿으로 쪼갠다
- 서버는 각 청크를 순차적으로 보낸다
- 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다
- 앞선 멀티파트 인코딩은 본문 인코딩이며, 이건 전송 인코딩이다.
- 지속 커넥션은 전체 크기를(Content-Length) 알아야 하는데 어떡할까
  - 크기를 0으로 보내서 받응은 응답 이후 다음 응답을 위해 커넥션을 열린채로 유지시킴
- 클라이언트는 청크 인코딩을 서버가 거절할 수 있으므로 411 응답코드에 대비해야 한다
### 전송 인코딩 규칙
- 전송 인코딩 집합은 반드시 `chunked` 포함해야 한다
- 청크 인코딩 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다
- 청크 인코딩은 반드시 한번 이상 적용되어야 한다
## 15.8 검사기와 신선도
- 캐싱 관련 클라이언트의 행동인듯
### 신선도
- 서버는 Expires 나 Cache-Control 헤더로 신선도 정보 제공
- 그런데 클라이언트, 서버의 시계 동기화가 항상 쉽지는 않아서, 절대시간(Expires) 대신 상대시간(Cache-Control) 사용이 쓸만함
### 조건부 요청과 검사기
- 조건부 요청 : 캐시가 만료되엇어도, 리소스가 바뀐 경우에만 사본을 요청하는 것
  - 조건부 GET 으로, If-modified-Since 로 Last-Modified 검사서 구현
  - 혹은 태그(If-Match 헤더와 ETag 검사기)
- 언제든 고유하게(unique) 식별가능한 검사기면 강한 검사기(암호 체크섬, ETag 등), 아니면 약한 검사기(최종 변경 시각, 1초단위라 ms 단위는 틀리기 때문)
- `W/` 붙이면 약한 엔티티 태그임을 알리고, 이게 바뀌더라도 다른 큰 게 바뀐거 아니면 캐시 재검사 안함

 ## 15.9 범위 요청
 - 실패한 http 엔티티를 다시 처음부터 받는게 아닌, 끊긴 부분부터 해서 일부 범위로 요청하는것
```
GET /bigfile.html HTTP1.1
Host: www.asdfsd.com
Range: bytes=4000-
```
- Range : 이거 기준으로 xxx바이트 이후의 부분을 요청 가능
- 서버가 클라이언트에게 범위 요청 받아들일 수 있는지는 응답에 Accept-Range 헤더를 포함시켜 알려줌. 헤더의 값은 측정 단위를 보냄(bytes 등)

## 15.10 델타 인코딩
- 클라이언트가 새로운 인스턴스(페이지 등) 요청하고, 서버에 새거가 있다면 아무리 일부의 변경이라도 전체의 인스턴스를 보내게 됨
- 변경된 부분만을 서버가 보낸다면 클라이언트는 더 빨리 인스턴스를 얻을 것 -> 이게 델타 인코딩
- http 프로토콜의 확장
- 클라이언트 입장
  - 클라이언트는 델타 적용기를 갖고 있어야 하고, 종류가 많기에 서버에 자신이 사용가능한 델타 적용기를 말함, 받은 델타 응답메시지로 페이지 수정
  - 클라이언트는 A-IM(Accept-Instance-Manipulation) 헤더에 델타 적용 종류 적음
- 서버 입장
  - 서버는 클라가 가진 델타 적용기에 맞게끔 델타 생성기를 사용해, 클라가 가진 버전과 새 버전의 차이점을 계산하여 델타 응답 메시지를 보냄
  - 서버는 클라이언트에게 델타 응답이라는 의미로 226 응답코드 반환,  
