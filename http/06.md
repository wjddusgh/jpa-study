# 6. 프락시

## 6.1 웹 중개자
- 클라이언트와 서버사이를 중개한다
- HTTP 프록시를 만든다면, http 클라이언트, 서버 모두의 규칙을 따라야 한다
- 개인 프록시
  - 하나의 클라이언트만을 위한 프록시
  - 주로 클라이언트 서버에서 직접 실행됨 
- 공용 프록시
  - 여러 클라이언트가 함께 사용
  - 비용효율이 높고 쉽다
  - 공통 요청들에서 이득을 취할 수 있음
- 게이트웨이와의 차이
  - 프록시는 같은 프로토콜 사용하는 둘 이상의 애플리케이션 연결 (http < 프록시 > http)
  - 게이트웨이는 서로다른 프로토콜 사용하는 둘 이상을 연결 (http < 게이트웨이 > pop(이메일서버))
  - 근데 사실 프록시도 ssl 여부, http 버전 차이 등 때문에 약간의 프로토콜 변환을 할 수도 있어서 게이트웨이랑 차이가 모호함
## 6.2 왜 프록시를 사용하는가?
- 모든 http 트래픽 들여다보고 건드릴 수 있어서 이를 통해 무언가 활용 가능
- 보안 개선(필터링, 익명화), 성능 높임, 비용 절약(트랜스코딩 등)
- 웹 캐시
- 대리 프록시(리버스 프록시) : 요청 받은거 처리 위해 다른 서버와 커뮤니케이션도 함

## 6.3 프록시는 어디에 있는가?
- 배치 방법
  - 출구 프록시 : 로컬 네트워크의 출구에 위치, 필터링에 잘 쓰임
  - 입구 프록시 : ISP 접근 지점, 캐시를 사용함
  - 대리(리버스) 프록시 : 웹 서버 바로앞에 위치, 필요할 때만 웹서버에게 자원 요청, 모든 요청은 얘한테 오게 됨
  - 네트워크 교환 프록시 : 네트워크 사이에 위치, 인터넷 교차로에서 캐시를 통해 혼잡 완화, 트래픽 흐름 감시
- 프록시 계층 : 프록시를 여쇄해 놓아 계층을 구성하는 것
  - 서버에 가까우면 손 윗 프록시 이다
  - 무조건 계층 따라 트래픽 보내진 않고, 유동적으로 보내기도 가능하다
    - 부하 균형
    - 지리적 인접성 근거한 라우팅
    - 프로토콜/타입 라우팅
    - 유료 서비스 가입자 위한 라우팅
- 클라이언트가 서버에 보낸 요청이 프록시로 가게되는 방법
  - 클라이언트가 모르게 네트워크 인프라에서 가로챈다(인터셉트 프록시), 이를 위해 스위치, 라우터가 이런 기능 갖고있어야함
  - DNS 이름공간을 리버스 프록시로 수정하거나 동적 dns 서버에서 수정
  - 웹서버에서 HTTP 리다이렉션으로 프록시에게 보내기
## 6.4 클라이언트 프록시 설정        
- 브라우저가 프록시 설정하는 방법
  - 수동 설정 : 명시적으로 성정
  - 브라우저 기본 설정 : 브라우저 벤더나 배포자가 미리 설정
  - 프록시 자동 설정(PAC, Proxy auto-configuration) : 자바스크립트 pac 파일에 대한 uri 제공
  - WPAD 프록시 발견 : 자동설정 파일을 다운받을 수 있는 설정 서버를 자동으로 찾아주는 웹 프록시 자동발견 프로토콜(WPAD) 제공
## 6.5 프록시 요청의 미묘한 특징들
- 프록시 uri 는 서버 uri 와 다르다
  - 서버 uri 는 요청 url 만 uri 로 가지고, 프록시 uri 는 프로토콜부터 포트 까지 완전한 uri 를 갖는다
  - 서버는 다른 정보를 이미 자신이 알아서 부분 uri 면 됐는데, 프록시는 몰라서 그렇다
- 가상 호스팅에서 일어나는 같은 문제
  - 스킴/호스트/포트번호 누락 문제는 가상호스팅도 같이 발생
  - 가상 호스팅 웹 서버는 누락된 정보가 담겨 있는 Host 헤더 요구   
- 인터셉트 프록시는 부분 uri 를 받게됨
- 다목적 프록시 서버는 그래서 부분 uri, 완전한 uri 모두 다룰 수도 있다
  - 프록시 서버에 온게 부분 Uri 면서 Host 헤더가 없는 경우 : 리버스 프록시라면 서버의 정보가 있다, 인터셉트 프록시라면 이전에 가로챈 트래픽 정보를 한번 봐본다, 모두 실패시 에러 반환
## 6.6 메시지 추적
- 통과하는 프록시가 하도 많아졌다.
- 프록시를 만드는 벤더도 많아졌다.
- 스위치, 라우터를 지나는 IP 패킷 추적과 비슷하게 프록시를 지나간 메시지 추적도 중요해졌다
### Via 헤더
- 메시지가 지나는 각 중간 노드(프록시 Or 게이트웨이) 정보를 나열
- ex. `Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com`
- 프록시는 저기에 적힐 유일한(unique) 문자열을 가지고 있으면서 기록해야함
- 갯수는 `,` 로 구분
- 문법
  - 프로토콜 이름 : HTTP 면 생략 가능
  - 프로토콜 버전
  - 노드 이름 : 가명으로 대체 가능
  - 노드 코멘트 : 예시로 캐시 프록시는 cache hit 여부 기록
- 여러 프록시 경로를 짧은 하나의 경로이름으로 합칠 수 있다 (1.1 abc.net, 1.1 def.com -> 1.1 abc-xyz) 예시처럼 프로토콜 이름, 버전이 같아야 할듯
### Trace 메서드
- HTTP/1.1 부터
- 프록시가 변환시킨 메시지 history 를 관찰/추적하도록 도와주는 메서드
- Max-Forwards 헤더 필드로 기록 최대 갯수 조절 가능
## 6.7 프록시 인증
- 제한된 콘텐츠 대한 요청 들어올 경우 407(Proxy Authoriztion Required) 상태를 Proxy-Authenticate(자격 제출 설명) 과 함께 반환
- 자격이 유효하면 통과, 실패시 다시 407 반환
- 서버는 401, 프록시는 407 인듯
## 6.8 프록시 상호 운용성
- 벤더가 다른 프록시들끼리는 서로 다른 버그와 기능을 소유중이라 동시 운용이 힘들기도 함
### 지원하지 않는 헤더와 메서드 다루기
- 프록시는 이해할수 없는 헤더는 반드시 그대로 전달해야함
- HTTP Options
  - 특정 URL에 대해 사용할 수 있는 HTTP 메서드들을 조회하기 위해 사용
- Allow
  - HTTP/1.1 명세에 정의된 OPTIONS 응답 헤더 
