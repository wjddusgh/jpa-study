1. 컴포넌트 응집도와 관련된 3가지 원칙중 컴포넌트를 더욱 작게 만들기 위한 배제 원칙은?
- 재사용/릴리스 등가 원칙
- 공통 폐쇄 원칙
- 공통 재사용 원칙
<details>
<summary> 정답 </summary>
 공통 재사용 원칙, 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다
</details>

2. 컴포넌트 의존성 그래프에서 순환이 발생시 어떤 해결방법이 있나요?

<details>
<summary> 정답 </summary>
  - 의존 역전(DIP) 를 통해 의존하는 컴포넌트에 인터페이스 만들기 <br/>
  - 의존하는 컴포넌트, 의존받는 컴포넌트 모두가 의존하는 새로운 컴포넌트 만들어 클래스드을 여기에 이동시키기
</details>

3. 정적 타입 언어에서 왜 추상 컴포넌트를 많이 사용할까요?
<details>
<summary> 정답 </summary>
  추상 컴포넌트는 거의 확실히 변하지 않을 거라는 아주 높은 안정성을 기대할 수 있기 때문에 컴포넌트들을 이 추상 컴포넌트에 의존하게 한다
</details>

4. 동적 타입 언어의 유연성은 무엇을 가능하게 해서 ISP를 더 유연하게 지킬 수 있는가?
<details>
<summary> 정답 </summary>
  덕 타이핑
</details>

5. 구체 클래스(ex. 자바의 String) 선언 하면서도 DIP 위배지만 무시할 수 있는 경우는?
<details>
<summary> 정답 </summary>
  그 구체 클래스가 변하지 않을거란 확신이 있을 정도로 안정적인 것일 때
</details>

6. 사실상 모든 언어에서 객체를 생성하려면 그에 대해 구체적으로 정의한 코드에 대한 의존성이 생기는데, 객체지향 언어에선 이를 처리하기 위해 무엇을 사용하나요? 
<details>
<summary> 정답 </summary>
  추상 팩토리 패턴
</details>

7. 옛날부터 지금까지 머피의 법칙으로 프로그램의 크기가 방대해져 프로그래머들은 고심했는데, 이를 이겨버린 규칙은?
<details>
<summary> 정답 </summary>
  무어의 법칙
</details>

8. Jar, dll, exe, gem 확장자 파일들을 뭐라고 하나요?
<details>
<summary> 정답 </summary>
   배포 단위의 컴포넌트
</details>


