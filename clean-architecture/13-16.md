1. 컴포넌트 응집도와 관련된 3가지 원칙중 컴포넌트를 더욱 작게 만들기 위한 배제 원칙은?
- 재사용/릴리스 등가 원칙
- 공통 폐쇄 원칙
- 공통 재사용 원칙
<details>
<summary> 정답 </summary>
 공통 재사용 원칙, 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다
</details>

2. 컴포넌트 의존성 그래프에서 순환이 발생시 어떤 해결방법이 있나요?

<details>
<summary> 정답 </summary>
  - 의존 역전(DIP) 를 통해 의존하는 컴포넌트에 인터페이스 만들기 <br/>
  - 의존하는 컴포넌트, 의존받는 컴포넌트 모두가 의존하는 새로운 컴포넌트 만들어 클래스드을 여기에 이동시키기
</details>

3. 정적 타입 언어에서 왜 추상 컴포넌트를 많이 사용할까요?
<details>
<summary> 정답 </summary>
  추상 컴포넌트는 거의 확실히 변하지 않을 거라는 아주 높은 안정성을 기대할 수 있기 때문에 컴포넌트들을 이 추상 컴포넌트에 의존하게 한다
</details>

4. 주계열 선분이라고도 저자가 부르는 이 구역에 위치한 컴포넌트는 어떤 특징이 있나요?
<details>
<summary> 정답 </summary>
  자신의 안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정 하지도 않다
</details>

5. 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다. 여기서 결정되지 않은 사항은 무엇이 있나요?
<details>
<summary> 정답 </summary>
  DB종류, 웹 서버, 프레임워크, REST, 혹은 웹 그자체의 적용 여부
</details>

6. 장치독립성을 통해, 동일한 프로그램을 아무 변경 없이도 입출력 장치를 변경할 수 있게 된건 SOLID의 어떤 원칙과 같나요? 
<details>
<summary> 정답 </summary>
  개방 폐쇄 원칙
</details>

7. 옛날부터 지금까지 머피의 법칙으로 프로그램의 크기가 방대해져 프로그래머들은 고심했는데, 이를 이겨버린 규칙은?
<details>
<summary> 정답 </summary>
  무어의 법칙
</details>

8. Jar, dll, exe, gem 확장자 파일들을 뭐라고 하나요?
<details>
<summary> 정답 </summary>
   배포 단위의 컴포넌트
</details>


