1. 객체지향의 세가지 본질적인 요소는 무엇일까요
<details>
<summary> 정답 </summary>
 다형성, 캡슐화, 상속
</details>

2. 객체지향(OO)의 등장으로 다형성을 아주 편리하게 쓸수 있게됐고, 그로인해 무엇들이 가능해지나요?
<details>
<summary> 정답 </summary>
  플러그인 아키텍처 적용
  의존역전
  모듈 독립
</details>

3. race condition, deadlock, concurrent update 는 모두 무엇 때문에 발생하나요?
<details>
<summary> 정답 </summary>
  가변 변수
</details>

4. 완벽한 함수형을 위해, 발생한 모든 트랜잭션을 저장하고, 값 필요 시 트랜잭션을 처리해 얻는 방법은?
<details>
<summary> 정답 </summary>
  이벤트 소싱
</details>

5. SOLID 원칙 중 메서드, 클래스 수준의 원칙은?
<details>
<summary> 정답 </summary>
  단일 책임 원칙, 개방 폐쇄 원칙
</details>

6. C언어는 추상화를 어떻게 제공하나요?
<details>
<summary> 정답 </summary>
 *.h 의 선언부, *.c 의 구현부로 나뉘고, header 는 멤버변수를 이름조차 알 수 없다
</details>

7. 트랜잭션 메모리 란?
<details>
<summary> 정답 </summary>
  데이터베이스 트랜잭션과 유사한 방식으로 병행 컴퓨팅에서 메모리의 접근을 제어하는 방법
</details>

8. 단일 책임 원칙을 위배하게 되는 징후 2가지는?
<details>
<summary> 정답 </summary>
   우발적 중복: 다른 곳에서 같은 메서드를 사용하게 됐고, 이게 수정이 되면 다른 사용자는 모를 수 있음
   병합 : 다른 책임이 한 클래스에 있어서 다른 사람들이 동시에 수정하면 병합 발생
</details>

4. 완벽한 함수형을 위해, 발생한 모든 트랜잭션을 저장하고, 값 필요 시 트랜잭션을 처리해 얻는 방법은?
<details>
<summary> 정답 </summary>
  이벤트 소싱
</details>

5. 프로그램 테스트를 통해 증명할 수 있는 것은?
<details>
<summary> 정답 </summary>
  프로그램에 뭔가 하자가 있을 때 프로그램이 잘못되었음을 증명한다. <br/>
  프로그램이 문제없음을 증명하진 못한다.  
</details>

