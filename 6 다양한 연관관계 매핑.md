# 6 다양한 연관관계 매핑
- 엔티티의 연관관계 매핑시 고려할 3가지
  - 다중성 : 연관관계가 있는 두 엔티티가 일대일 관계인지 일대다 관계인지
    - 다중성의 종류 : 다대일, 일대다, 일대일, 다대다 
  - 단방향, 양방향
    - 객체 관계에서 한 쪽만 참조하면 단방향, 양쪽이 서로 참조하면 양방향 
  - 연관관계의 주인 : 양방향 관계라면 누가 주인인지
    - 주인은 mappedBy 속성을 사용하지 않는다
 
 - 다중성과 단방향, 양방향을 고려한 모든 연관관계
  - 다대일: 단방향, 양방향
  - 일대다: 단방향, 양방향
  - 일대일: 주 테이블 단방향, 양방향
  - 일대일: 대상 테이블 단방향, 양방향
  - 다대다: 단방향, 양방향 (실무에서 거의 쓰이지 않는다)

# 6.1 다대일
일대다 와 다대일은 서로의 반대 관계, 항상 다 쪽이 연관관계의 주인

## 6.1.1 다대일 단방향[N:1]
다 쪽에서 일을 참조하는 필드 보유

## 6.1.2 다대일 양방향[N:1, 1:N]
- 양방향은 외래키가 있는 쪽이 연관관계의 주인이다
  - 주인이 아닌 참조는 조회를 위한 JPQL 이나 객체 그래프 탐색시 사용
- 양방향 연관관계는 항상 서로를 참조해야 한다
  - 연관관계 편의 메소드를 사용하면 좋다(양 쪽에 다 작성시 **무한루프** 주의)  

# 6.2 일대다
일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 Collection, List, Set, Map 중에 하나 사용

## 6.2.1 일대다 단방향[1:N]
- 일대다 단방향 관계는 JPA 2.0부터 지원한다
- 외래 키가 없는 테이블과의 매핑이라 어지럽다
- @JoinColumn 을 명시해야 JPA 가 연결테이블을 중간에 두고 연관관계를 관리하는 조인테이블 전략을 기본으로 사용해서 매핑한다
```java
@Entity
public class Team {
  @Id
  @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  @OneToMany
  @JoinColumn(name = "TEAM_ID") //MEMBER 테이블의 FK
  private List<Member> members = new ArrayList<Member>();
  
  ...
}
```
- 일대다 단방향 매핑의 단점
  - 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점
  - 이 때문에 엔티티의 저장과 연관관계 처리를 INSERT 한번이 아니라 UPDATE를 추가로 실행해줘야함
    - Member 엔티티는 Team을 모르기에 직접 update로 MEMBER테이블의 TEAM_ID를 갱신해줘야함
 
결론: 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자

## 6.2.2 일대다 양방향[1:N, N:1]
일대다 양방향 매핑은 존재하지 않는다. 대신 다대일 양방향 매핑을 사용해야 한다(연관관계의 주인이 다 쪽 이라는 뜻)
- 그런데 일대다 양방향 매핑이 완전히 불가능한 것은 아니다
  - 일대다 단방향 매핑 반대편에 같은 외래 키를 사용하는 다대일 단방향 매핑을 읽기전용으로 하나 추가하면 된다
  - 하지만 일대다 단방향 매핑의 단점을 그대로 가지므로 별로다

# 6.3 일대일[1:1]
- 일대일 관계의 특징
  - 일대일 관계는 그 반대도 일대일 관계다
  - 테이블 관계에서 일대다, 다대일 은 항상 다(N) 쪽이 외래 키를 가진다. 반면에 일대일 관계는 어느곳에나 외래 키를 가질 수 있다
  - 일대일 관계는 주 테이블이나 대상 테이블 중에 누가 외래 키를 가질지 선택해야 한다 
    - 주 테이블에 외래 키: 외래 키를 객체 참조와 비슷하게 사용할 수 있어서 객체지향 개발자들이 선호, 주 테이블만 학인해도 외래 키가 있어서 대상 테이블과 연관관계 있는지 알 수 있다 
    - 대상 테이블에 왜래 키: 전통적인 데이터베이스 개발자들이 선호, 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지할 수 있다

## 6.3.1 주 테이블에 외래 키
- JPA 도 주 테이블에 외래 키가 있으면 좀 더 편리하게 매핑할 수 있다
### 단방향
```java
@Entity
public class Member {
  @Id
  @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @OneToOne
  @JoinColumn(name = "LOCKER_ID")
  private Locker locker;
  ...
}

@Entity
public class Locker {
  @Id
  @GeneratedValue
  @Column(name = "LOCKER_ID")
  private Long id;
  
  private String name;
  ...
}
```
- 디비에서는 LOCKER_ID에 유니크 제약 조건 걸어놓은 상태
### 양방향
```java
@Entity
public class Member {
  @Id
  @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @OneToOne
  @JoinColumn(name = "LOCKER_ID")
  private Locker locker;
  ...
}

@Entity
public class Locker {
  @Id
  @GeneratedValue
  @Column(name = "LOCKER_ID")
  private Long id;
  
  private String name;
  
  @OneToOne(mappedBy = "locker")
  private Member member;
  ...
}
```
- 대상 테이블 
```엔ㅇ
```
```
