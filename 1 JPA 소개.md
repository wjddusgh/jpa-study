자바로 데이터베이스에 접근할 때 SQL 매퍼를 사용할수도, ORM 을 사용할 수도 있다.\
지금부터 SQL을 직접 다룰 때 어떤 문제가 발생하는지, 객체와 RDS 사이엔 어떤 차이가 있는지 알아보자

# 1.1 SQL을 직접 다룰 때 발생하는 문제점

관계형 데이터베이스는 가장 대중적이고 신뢰할만한 안전한 데이터 저장소다.\
자바 애플리케이션은 `JDBC API`를 사용해서 DB에 접근한다.

## 1.1.1 반복, 반복 그리고 반복
SQL을 직접 다루어서 DB에 접근한다면 모든 CRUD에 String 타입의 SQL이 들어가게된다.\
그리고 또한 반복적으로 Statement를 만들고 ResultSet을 반환받아 객체에 옮기는작업 계속한다.
- DB가 아닌 메모리에 저장한다면?
  - `list.add(member)` 헌쥴 컷 
- 하지만 DB와 객체의 차이점 때문에 바로 접근하여 CRUD는 불가능하고 개발자가 변환작업 해주어야 한다.
- 이러한 작업의 수는 테이블 수만큼 늘어나게 되는데, 비슷한 작업의 반복이다.

## 1.1.2 SQL에 의존적인 개발
기능을 수정해달라는 요구사항이 들어온다면?
- DB에 접근하여 수행하는것은 결국 SQL인데 이건 String 타입이다.
- 열심히 직접 코드를 수정해서 고쳐야한다.
- 객체로 변환하는 작업에서도 코드 열심히 직접 수정한다.
로직에서 에러가 발생한다. 근데 서비스 로직은 문제가 없는거 같다. 어떡하지?
- DAO 코드를 들여다봐야한다.
- 기껏 서비스와 데이터 접근 레포지토리를 분리시켰는데 서비스가 SQL에 의존하게 된다.
- 결국 서비스는 엔티티를 신뢰할 수 없다.

## 1.1.3 JPA와 문제 해결
JPA(자바 ORM) 은 대부분의 객체, DB간 변환과정을 자동으로 해준다.\
개발자는 JPA가 제공하는 API를 사용하면 된다.\
CRUD 예시
- 저장 기능\
`jpa.persist(member);`
- 조회 기능\
`jpa.find(Member.class, memberID);`
- 수정 기능
```java
Member member = jpa.find(Member.class, memberID);
member.setName("누구로");
```
- 연관된 객체 조회
```java
Member mem = jpa.find(Member.class, id);
Team team = mem.getTeam();
```

# 1.2 패러다임의 불일치

애플리케이션은 발전하면서 내부 복잡성도 커진다.\ 
객체지향 프로그래밍은 다양한 시스템 복잡성을 제어할 수 있는 장치를 제공해준다. \
그래서 현대의 복잡한 애플리케이션은 대부분 OOP로 개발한다.\
비즈니스 요구사항을 정의한 도메인 모델도 객체로 모델링하면 장점 활용 가능하다.\
객체는 기능, 속성이 있는데 그중 속성(필드) 만 DB에 저장한다면 훌륭한다.\
문제는, 객체 참조 때문에 RDB에 저장하는게 좋은데 객체지향과 관계형디비는 패러다임이 다르다.

## 1.2.1 상속
- 객체는 상속 기능을 갖고있지만 테이블은 상속 기능이 없다.
- 그래서 테이블은 상속을 표현하기 위해 부모객체가 자식객체 타입 저장하는 필드가 필요하고, 자식은 부모id를 fk로 가진다
- CRUD도 무려 부모,자식 두개의 SQL이 필요하게된다.
- 너무 손해가 크다. 메모리였다면 `list.add(movie);` 처럼 부모자식 고민없이 컬렉션 사용하면 된다.
JPA와 상속
- JPA는 상속과 관련하여 객체의 상속관계를 확인하고 알아서 다해준다!

## 1.2.2 연관관계
객체는 참조를 사용해서 연관객체를 조회하지만, 테이블은 외래 키(FK) 를 통한 조인을 사용해서 연관 테이블을 조회한다.\
여기서 문제, 객체는 참조가 있는 방향으로만 조회할 수 있지만, 테이블은 양쪽에서 JOIN 가능하다.
- 객체를 테이블에 맞추어 모델링 : 객체에서 다른 객체 id 알아봤자 바로 접근 못한다.
- 객체지향 모델링 : 참조객체 접근 가능, 근데 테이블에 저장, 조회가 어려워짐(귀찮게 개발자가 객체를 테이블에 맞게 변환 해줘야함)

JPA와 연관관계
- JPA는 알아서 다해준다. 참조 알아서 다확인해서 다한다.

## 1.2.3 객체 그래프 탐색
객체의 참조를 쭉 탐색하는것이 그래프 탐색이다.\
- SQL을 직접 다루면 객체 전체를 가지고오지 않는 이상 참조 탐색하다가 막힌다. 이것은 쉽게 해결할 수 없는 문제

JPA와 객체 그래프 탐색
- 아 역시나 JPA는 `지연로딩` 을 통해 조회를 미뤄 해결한다. 물론 지연로딩을 안하도록 변경도 가능하다.

## 1.2.4 비교
데이터베이스는 기본키의 값으로 각 로우 를 구분하고, 객체는 동일성비교, 동등성비교 로 구분한다.
- 동일성 비교 : `==`
- 동등성 비교 : `equals()`
SQL매퍼를 사용해 같은 값의 객체를 두번 불러오고 비교하면 안타깝게도 다르다고 나옴
- 두개의 인스턴스기 때문에 동일성비교는 false, 동등성 비교는 true

JPA와 비교
- 한 트랜잭션에서 같은 값의 객체를 불러오면 재사용해서 반환하기에 동일성 비교도 true 나온다.

## 1.2.5 정리
객체 모델과 관계형DB 모델은 지향하는 패러다임이 서로 다르다. 그로인해 개발자는 패러다임 차이 극복에 많은 리소스를 소비한다.\
JPA는 많은 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.

# 1.3 JPA란 무엇인가?

JPA(Java Persistence API)는 자바 진영의 ORM 표준 기술이다.\
JPA는 애플리케이션과 JDBC 사이에서 동작한다.\
ORM(Object-Relational Mapping)이란?
- 객체와 관계형 데이터베이스를 매핑한다는 뜻
- 매핑을 통해 패러다임의 불일치 문제를 개발자 대신 해결해줌
하이버네이트(Hibernate)는 성숙한 자바 ORM 프레임워크다.

## 1.3.1 JPA 소개
과거 자바 진영은 엔터프라이즈 자바 빈즈(EJB) 라는 기술 표준을 만들었는데 그중엔 엔티티 빈 이라는 ORM도 포함됐었다. \
근데 너무 별로인 와중에 하이버네이트라는 오픈소스 ORM 이 등장했고 결국 EJB 3.0부터 하이버네이트 기반 표준이 생기고 그게 JPA다.\
- JPA는 자바 ORM 기술에 대한 API 표준 명세, 즉 인터페이스를 모아둔 것이다.
JPA 버전별 특징
- JPA1.0 (2006):초기버전, 복합키와 연관관계 기능 부족
- JPA2.0 (2009):대부분의 ORM 기능 포함하고 JPA Criteria 추가
- JPA2.1 (2013):스토어드 프로시저 접근, 컨버터, 엔티티 그래프기능 추가

## 1.3.2 왜 JPA를 사용해야 하는가?
생산성
- 지루하고 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다.
- DDL문을 자동으로 생성해주는 기능도 있다.
- 이러한 기능들을 통해 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

