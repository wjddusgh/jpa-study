1. 커맨드 패턴에서 커맨드는 무엇들을 가지고 있나요? 그리고 그건 왜 갖고있나요?
<details>
<summary> 정답 </summary>
  리시버들을 갖고있다. 리시버는 작업을 처리하는 애들로, 작업을 요청하는 인보커와 분리하기 위해서
</details>

2. null 객체란?
<details>
<summary> 정답 </summary>
   null 값에 대한 처리를 하지 않고, 어떠한 객체에 대해 빈 값을 처리해주기 위한 객체. 커맨드 패턴에서는 execute() {} 로 아무것도 안하게 하면 된다. 책예제에서는 커맨드가 없는 경우를 대비하기 위해 NoCommand() 객체가 있었다.
</details>

3. 이걸봅시다
```java
// 잠잘 때 완벽한 선풍기 속도를 찾아버렸다.
// 다음날 잠결에 찾은거라 그 속도를 잊었다.
// 뛰어난 우리 리모콘에는 undo() 가 있는걸 깨달았다.
```
<details>
<summary> 정답 </summary>
  static이 없으니 getInstance()는 인스턴스에 속하는 메서드가 되고, 생성자가 private이니 인스턴스는 생기지도 못하고. 아무것도 못합니다.
  인스턴스가 있다 해도, 모든 인스턴스마다 다른 getInstance() 이므로 호출시 모두 다른 결과를 반환할수도 있습니다.
</details>

4. 싱글턴 패턴이 멀티스레딩에서 터진다면 이유는 무엇이고, 어떻게 해결하나요?
<details>
<summary> 정답 </summary>
  여러 스레드에서 동시에 if(instance == null) 통과 해버리면 여러곳에서 new 를 통한 인스턴스 생성되어 한개가 아니게 됨
  이건 synchronized 같은 동기화만 추가해주면 되긴 하는데 느려짐
  속도가 중요하면 미리 만들고 if문 없애자
  아니면 DCL(Double Check Locking) 하면 처음 한번만 동기화 된다. 그리고 volatile 사용 시 모든 스레드가 같은 변수를 바라보게 된다
</details>

5. 싱글턴 패턴의 서브클래스를 만들어도 되나요?
<details>
<summary> 정답 </summary>
  생성자가 private이라 곤란합니다. 싱글턴 패턴을 서브클래스를 만들어야 할정도라면 비즈니스 로직이 싱글턴에 과하게 많은건 아닌지 검토합시다
</details>
