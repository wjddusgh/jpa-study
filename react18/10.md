# 10. 리액트 18의 새로운 기능들
- 상태 업데이트의 자동 배치: 여러 상태 업데이트를 자동으로 단일 업데이트로 배치
- 동시 렌더링
- Suspense
- 개선된 에러 핸들링
- 인터넷 익스플로러 11 미지원
## 동시 모드(Concurrent Mode)
- 전통적인 리액트 렌더링 프로세스는 동기식
- 동시 모드는 리액트가 여러 태스크를 동시에 작업하도록 함

### 동시 모드의 핵심 기능
- 시분할: 큰 작업 덩어리를 작은 조각으로 나누고, 중요한 태스크의 우선순위를 높이는 기법
- Suspense: 필요한 데이터가 로드될 때까지 컴포넌트 렌더링 대기시킴
- 동시 렌더링: 사용자 인터페이스를 좀 더 빈번하게 업데이트하며 한층 부드러운 애니메이션, 전환을 제공# 10. 리액트 18의 새로운 기능들
- 상태 업데이트의 자동 배치: 여러 상태 업데이트를 자동으로 단일 업데이트로 배치
- 동시 렌더링
- Suspense
- 개선된 에러 핸들링
- 인터넷 익스플로러 11 미지원
## 동시 모드(Concurrent Mode)
- 전통적인 리액트 렌더링 프로세스는 동기식
- 동시 모드는 리액트가 여러 태스크를 동시에 작업하도록 함

### 동시 모드의 핵심 기능
- 시분할: 큰 작업 덩어리를 작은 조각으로 나누고, 중요한 태스크의 우선순위를 높이는 기법
- Suspense: 필요한 데이터가 로드될 때까지 컴포넌트 렌더링 대기시킴
- 동시 렌더링: 사용자 인터페이스를 좀 더 빈번하게 업데이트하며 한층 부드러운 애니메이션, 전환을 제공

```javascript
function Counter() {
  const [count, setCount] = useState(0)

  function handleClick() {
    setCount(count + 1)
  }
  return (
    <button onClick={handleClick}>
      {count}
    </button>
  }
}
function App() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <Counter />
    </React.Suspense>
  )
}

 // 동시모드 활성화(시분할, 동시 렌더링 내부적으로 진행)
ReactDOM.createRoot(document.getElementById('root')).render(<App />) 
```

## 자동 배치
- 기존엔 사용자 인터페이스 업데이트는 동기화돼 처리되어서, 각 업데이트가 새로운 렌더 경로를 트리거함
- 여러 업데이트가 빠르게 연속되는 경우 대단히 비효율적
- 자동 배치는 여러 업데이트를 그룹화하고 이들을 하나의 렌더 경로에서 처리하게함
```js
function MyComponent() {
  const [count, setCount] = useState(0)

  function handleClick() {
    setCount(count + 1)
    setCount(count + 1)
    setCount(count + 1)
  }

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  )
}
```
- 자동 배치로 인해 setCount() 마다 렌더링이 아닌, setCount() 세번의 실행이 끝난 후 렌더링 진행

## 트랜지션
- 애플리케이션에서 부드러운 선언적 애니메이션과 전환 만들기 가능
```js
import { useState } from 'react'
import { Transition } from 'react-transition-group'

function MyComponent() {
  const [show, setShow] = useState(false)

  function handleClick() {
    setShow(!show)
  }

  return (
    <div>
      <button onClick={handleClick}>
        {show ? 'Hide' : 'Show'}
      </button>
      <Transition in={show} timeout={300}>
        {state => (
          <div
            style={{
              transition: 'opacity 300ms ease-out',
              opacity: state === 'entered' ? 1 : 0
            }}
          >
            {show && <p>Hello, world!</p>}
          </div>
        )}
      </Transition>
    </div>
  )
}

```
- `react-transition-group` 라이브러리의 `Transition` 컴포넌트
  - in: 엘리먼트의 나타남, 사라짐 결정
  - timeout: 전환 시간, 밀리초 단위
  - 내부적으로 4가지 상태값 존재
    - entering, entered, exiting, exited
   
## 서버에서의 Suspense
- 리액트 18 이전의 Suspense 는 주로 CSR 에서 비동기 데이터로딩, 코드 분할을 관리하기 위해 이용됨
- 리액트 18부터는 서버에서도 대기를 사용할수 있어서 SSR 렌더링 최적화 가능

### 서버에서의 Suspense 동작
- 서버 렌더드 컴포넌트의 첫 렌더링을 진행하는 동안 모든 대기 경계가 등록되고, 메인 컨텐츠 대신 대체(fallback) 컨텐츠 렌더링
- 데이터 로딩, 코드 분할 필요시 서버는 대기 경계에 해당하는 대체 컨텐츠를 가진 플레이스홀더 HTML 응답 반환
- 비동기 데이터나 코드가 로드되면 클라이언트는 대기 경계에 실제 컨텐츠를 삽입
- 이러면 컴포넌트 트리의 준비되지 않은 부분은 대체 컨텐츠를 보여주면 되니 빠른 렌더링이 가능
```js
import { Suspense } from 'react'
import { fetchUserData } from './api'

function MyComponent() {
  const userData = fetchUserData()

  return (
    <div>
      <p>Name: {userData.name}</p>
      <Suspense fallback={<p>Loading...</p>}>
        <UserProfile userId={userData.id} />
      </Suspense>
    </div>
  )
}

```

## 신규 API
### createRoot
- 전통적으로 `ReactDOM.render` 메서드 사용하여 루트 엘리먼트와 그 안에 렌더링할 리액트 컴포넌트 지정했음(결국 reder() 다시하면 덮어씌워짐)
- `createRoot` 사용 시 하나의 루트 엘리먼트를 만들고, 여러 컴포넌트 렌더링 가능(여러번 선언하면 여러 컴포넌트를 루트가 관리)
- 동시 모드 기능 사용 가능, 리액트 18이후 추가된 SSR 관련 메서드 호환 가능

### hydrateRoot
