# 8 프록시와 연관관계 관리
- 객체 그래프 탐색 시 연관된 객체들은 DB에 저장되어 있으므로 마음껏 탐색하기 어렵다
- 프록시 사용시 연관객체를 선언 시점이 아닌 실행 시점에 DB 조회할 수 있다 (지연 로딩)
- JPA 는 즉시 로딩, 지연 로딩 모두 지원한다
- JPA 는 연관 객체를 한번에 저장, 삭제할 수 있는 영속성 전이와 고아 객체 제거 등의 편리한 기능을 제공한다

# 8.1 프록시

- 비즈니스 로직 상 연관 엔티티가 항상 사용되는 것은 아니다
- 엔티티를 사용하지 않는데 같이 조회해오는것은 손해
- 지연로딩을 사용하자, 실제 엔티티 대신에 가짜 객체 (프록시 객체) 를 넣어둔다
- 지연로딩 구현은 JPA 구현체에 위임했음 -> 책에서는 하이버네이트 구현 내용

## 8.1.1 프록시 기초
- JPA 에서 엔티티 조회시 `EntityManager.find()` 사용
  - 이렇게 직접 조회하면 연관엔티티 다 가져옴
- `EntityManager.getReference()` 사용 시 조회를 미룰 수 있다
  - 메소드 호출 시 조회, 엔티티객체 생성을 하지 않고 프록시 객체만 반환
- 프록시의 특징
  - 실제 클래스를 상속받아서 만들어지므로 사용자는 이 객체가 진짜인지 프록시인지 구분하지 않고 사ㅛㅇ하면 된다
  - 프록시 객체는 실제 객체에 대한 참조(target) 을 보관하고, 프록시 객체 메소드 호출 시 프록시 객체는 실제 객체의 메소드를 호출한다
  - 프록시 객체의 초기화 : 실제 사용 시점에 DB 조회해 실제 엔티티 객체 생성을 프록시 객체 초기화 라고 함    
  - 프록시 객체는 처음 사용 시 단 한번만 초기화 된다
  - 초기화 한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다
  - 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크시에 주의해서 사용해야 한다
  - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `getReferencet()` 호출해도 프록시가 아닌 실제 엔티티를 반환한다
  - 초기화는 영속성 컨텍스트의 도움을 받아야 가능하므로, 준영속 상태의 프록시를 초기화 하면 문제가 발생
    - JPA는 따로 문제 명세가 없고 하이버네이트는 `org.hibernate.LazyInitializationException` 예외 발생

## 8.1.2 프록시와 식별자
- 엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 잔달하고, 프록시 객체는 이 식별자 값을 보관한다
```java
Team team = em.getReference(Team.class, "team1"); //식별자 : "team1"
team.getId(); // 이미 있는값, 프록시객체 초기화 X
```
- 단, 엔티티 접근 방식을 프로퍼티로 설정한 경우에만 초기화 되지 않는다
- 필드 접근 방식의 경우 `getId()` 메소드가 id만 조회하는 메소드인지 다른 필드까지 활용하는지 모르므로 프록시 객체를 초기화한다
- 연관관계 설정 시 식별자 값만 사용하므로 프록시 사용하면 DB 접근 횟수를 줄일 수 있다
  - 참고, 연과노간계 설정 시 엔티티 접근 방식이 필드여도 프록시 초기화 X

## 8.1.3 프록시 확인
- JPA 가 제공하는 `PersistenceUnitUtil.isLoaded(Object entity)` 메소드 사용 시 프록시 인스턴스의 초기화 여부를 알 수 있다
  - 아직 초기화 되징 않았으면 `false`, 초기화됐거나 프록시 인스턴스가 아니면 `true` 반환
- 조회한 엔티티가 진짜 엔티티인지 프록시인지 확인하려면 클래스명을 직접 출력해보면 된다
  - `getClass().getName()` 사용해 출력시 `..javassist..` 문구가 붙어있으면 프록시이다
- 하이버네이트의 `initialize()` 메소드 사용 시 프록시를 강제로 초기화 할 수 있다
  - JPA 표준에는 강제 초기화 메소드가 없기 때문에 프록시 메소드 직접 호출로만 가능하다

# 8.2 즉시 로딩과 지연 로딩

- 즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다
  - ex. `em.find(Member.class, "member1")` 호출 시 회원 엔티티와 연관된 Team 엔티티도 함께 조회
  - 설정 방법: `@ManyToOne(fetch = FetchType.EAGER)`
- 지연 로딩 : 연관된 엔티티를 실제 사용할 때 조회한다
  - ex. 'member.getTeam().getName()` 처럼 조회한 팀 엔티티를 실제 사용할 때 JPA가 SQL을 호출해서 팀 엔티티를 조회한다
  - 설정 방법: '@ManyToOne(fetch = FetchType.LAZY)`  

## 8.2.1 즉시 로딩
- 연관된 엔티티를 함께 가져오므로 쿼리를 여러번 실행할 것 같지만 그렇지 않다
- 대부분의 JPA 구현체는 즉시 로딩을 최적화 하기 위해 간으하면 조인 쿼리를 사용한다
- 외래 키값이 NULL 일수도, NOT NULL 제약조건이 있을수도 있다
  - `@JoinColumn의 nullable`,또는 `@ManyToOne의 optional`을 통해 조인을 고를 수 있다
  - nullable = false 또는 optional = false : 내부 조인 사용
  - nullable = true 또는 oprional = true : 외부 조인 사용

## 8.2.2 지연 로딩
- `em.find(Member.class, "member1")` 호출시 team 필드엔 프록시 객체를 넣는다
- 물론 team 객체가 영송석 컨텍스트에 이미 있다면 프록시 객체가 아닌 실제 엔티티를 넣는다
```sql
SELECT * FROM MEMBER
WHERE MEMBER_ID = 'member1'
```
- 이후 `team.getName()` 등 team 객체 메소드 호출시 SQL 실행되면서 프록시 객체 초기화 한다

## 8.2.3 즉시 로딩, 지연 로딩 정리
- 지연 로딩(LAZY) : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다
- 즉시 로딩(EAGER) : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다

# 8.3 지연 로딩 활용

- 사내 주문 관리 시스템 개발 예시
- 회원<>팀(N:1), 회원<>주문내역(1:N), 주문내역<>상품(N:1)
- 회원, 팀은 자주 함께 사용 -> 즉시 로딩
- 회원, 주문내역은 가끔 사용 -> 지연 로딩
- 주문내역, 상품은 자주 함께 사용 -> 즉시 로딩

```java
@Entity
public class Member {

  @Id
  private String Id;
  private String username;
  private Integer age;
  
  @ManyToOne(fetch = FetchType.EAGER)
  private Team team;
  
  @OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
  private List<Order> orders;
  
  ...
}
```
- 회원 조회 시 team 은 즉시 로딩이므로 조인 쿼리를 통해 함께 가져온다
- 주문내역은 지연 로딩이므로 프록시 객체만 반환한다

## 8.3.1 프록시와 컬렉션 래퍼
- 컬렉션 래퍼 : 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경
  - `org.hibernate.collection.internal.PersistentBag` 이 반환
- 컬렉션 지연 로딩은 컬렉션 래퍼가 처리해준다
- `member.getOrders()` 를 호출해도 컬렉션은 초기화되지 않는다
- `member.getOrders().get(0)` 처럼 컬렉션에서 실제 데이터를 조회할 때 DB를 조회해서 초기화한다

## 8.3.2 JPA 기본 페치 전략
- fetch 속성의 기본 설정값
  - @ManyToOne, @OneToOne : 즉시 로딩
  - @OneToMany, @ManyToMany : 지연 로딩
- 연관된 엔티티가 하나면 즉시로딩, 컬렉션이면 지연 로딩이 기본 전략이다 (컬렉션 로딩은 비용이 큼)
- 추천하는 방법은 모든 연관관계에 지연 로딩을 사용하고, 개발 완료단계에서 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화 (SQL 매퍼는 이런 유연한 최적화 힘듦)

## 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다
  - 컬렉션과 조인한다는 것은 DB 테이블로 보면 일대다 조인으로, 결과 데이터가 다 쪽에 있는 수만큼 증가하게 된다
  - 서로다른 컬렉션 2개 이상 조인 시 N * M 크기가 되버린다. JPA는 이렇게 조회된 결과를 메모리에서 필터링해서 반환한다
- 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다
  - not null 제약조건이 없는데 내부조인하면 회원이 한명도 없는 팀은 그 팀까지 조회되지 않는 문제가 발생한다
  - 그래서 @OneToMany, @ManyToMany 는 optional = false 여도 외부조인 한다

# 8.4 영속성 전이: CASCADE

- 부모 자식 엔티티를 저장할 때 JPA는 저장할 모든 데이터가 영속상태여야 한다
- 그래서 각각 부모, 자식들을 `em.persist()` 해야 한다

## 8.4.1 영속성 전이: 저장
```java
@Entity
public class Parent {
  ...
  @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
  private List<Child> children = new ArrayList<Child>();
  ...
}
```
- cascade 옵션을 준 상태면 그저 persist 전에 부모 엔티티에 자식을 세터로 넣고 한번만 부모를 persist하면 된다
- 영속성 전이는 연관관계 매핑과는 아무 관련이 없고, 엔티티 영속화 할 때 연관 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다

## 8.4.2 영속성 전이: 삭제
- `CascadeType.REMOVE` 사용시 위의 저장 처럼 부모 엔티티 삭제 시 자식 엔티티도 함께 삭제된다
- 코드 실행 시 DELETE SQL이 여러번 실행되는데, 외래 키 제약조건을 고려해서 자식을 먼저 삭제하고 부모를 삭제한다
- 영속성 전이 없이 부모를 삭제하면 외래 키 제약조건으로 인해 DB에서 외래키 무결성 예외가 발생한다

## 8.4.3 CASCADE의 종류
```java
public enum CascadeType {
  ALL,
  PERSIST,
  MERGE,
  REMOVE,
  REFRESH,
  DETACH
}
```
- 여러 속성을 같이 사용할 수 있다 `cascade = { CascadeType.PERSIST, CascadeType.REMOVE }`
- 참고로 PERSIST, REMOVE 는 코드 실행시 바로 전이가 발생하는게 아니고, 플러시 호출 시 전이가 발생한다

# 8.5 고아 객체

- JPA 는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공한다 (고아 객체 제거)
- 이 기능 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제되도록 할 수 있다
- `@OneToMany(mappedBy = "parent", orphanRemoval = true)`
- 이 기능은 참조하는 곳이 하나일 때만 사용해야 한다 (@OneToOne, @OneToMany 에만 사용가능)
- 개념적으로 볼 때 부모를 제거하면 자식은 고아가 되므로 같이 삭제하는데 CascadeType.REMOVE와 같은 기능

# 8.6 영속성 전이 + 고아 객체, 생명주기

- CascadeType.ALL + orphanRemoval = true 를 동시에 사용하면 어떻게 될까?
- 자식 엔티티의 생명 주기를 부모 엔티티를 통해서 관리할 수 있게 된다
  - 자식 저장은 부모에 세터로 등록만 하면 된다
  - 자식 삭제는 부모에서 제거만 하면 된다

# 8.7 정리

- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 프록시 기술 사용
- 객체를 조회할 때 연관된 객체를 즉시 로딩할 수도 있고, 지연해서 로딩할 수도 있다
- 객체를 저장, 삭제할 때 연관된 객체도 함께 처리할 수 있는데 이것을 영속성 전이라 한다
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면 된다
